{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"source/images/ckxt0.jpg","path":"images/ckxt0.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/6948382.jpg","path":"images/6948382.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1459279410000},{"_id":"themes/yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1465107134348},{"_id":"themes/yilia/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1465107134452},{"_id":"themes/yilia/_config.yml","hash":"043aeafd93849dd325ee07704b442cb102e54c15","modified":1465217079927},{"_id":"source/_posts/Broadcast广播.md","hash":"de2ea996f17f0367a224a9cf3815e415d42fe2ec","modified":1466313084133},{"_id":"source/_posts/关于Java单例模式.md","hash":"6b30844d3b9f7f46b2bed4ebabd11735d15d4127","modified":1466311912054},{"_id":"source/_posts/HandlerThread-Handler-Thread.md","hash":"155bfa86a5383de235c251fefcc0397bd3884869","modified":1465547209750},{"_id":"source/_posts/DatePickerDialog-TimePickerDialog在某些机型上会连续返回两次结果.md","hash":"0b50d2484afb363ec019bed6ffdc9fb31699ac35","modified":1465553225916},{"_id":"source/_posts/首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用.md","hash":"9481c2afea9f4ee4bb5aab1420a8f3074167e800","modified":1465547309444},{"_id":"source/images/favicon.ico","hash":"7fb252cbc954830588dd11ae3fa0a14ca2c9f0d3","modified":1465216702013},{"_id":"source/images/avatar.jpg","hash":"e5c214e78166847fbc688ac2cc914b0270271206","modified":1465214690868},{"_id":"themes/yilia/languages/default.yml","hash":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1465107134353},{"_id":"themes/yilia/languages/de.yml","hash":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1465107134352},{"_id":"themes/yilia/languages/en.yml","hash":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1465107134355},{"_id":"themes/yilia/languages/ru.yml","hash":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1465107134357},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1465107134355},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"d2336578e14bb880d152266981c2b17523fc8742","modified":1465107134359},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1465107134361},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1465107134362},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1465107134440},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1465107134441},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1465107134443},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1465107134449},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1465107134449},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1465107134513},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1465107134451},{"_id":"themes/yilia/layout/layout.ejs","hash":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1465107134447},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1465107134514},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1465107134514},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1465107134515},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1465107134515},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1465107134515},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1465107134535},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"004bb0812414554ab48067792f09e978603253b6","modified":1465107134541},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"9c34c37b4dca82386648d364da913153d1db902e","modified":1465107134567},{"_id":"themes/yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1465107134563},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1465107134549},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1465107134550},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1465107134550},{"_id":"themes/yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1465107134573},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1465107134551},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1465107134551},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1465107134551},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1465107134552},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1465107134552},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1465107134589},{"_id":"themes/yilia/source/js/mobile.js","hash":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1465107134584},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1465107134553},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1465107134553},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1465107134553},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1465107134554},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1465107134554},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1465107134554},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1465107134555},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1465107134555},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1465107134555},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1465107134555},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1465107134555},{"_id":"themes/yilia/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1465107134454},{"_id":"themes/yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1465107134497},{"_id":"source/images/ckxt0.jpg","hash":"980ebd08b10b0f3b9bf2603dc38d45842cc50d15","modified":1465125414262},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1465107134513},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1465107134455},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1465107134380},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1465107134378},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1465107134399},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1465107134387},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1465107134402},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"2bbf5aad03f54055d9d7852e70ff7e6952a41f26","modified":1465107134405},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1465107134408},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1465107134415},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1465107134413},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"420b94c78832456686ebd9831a5bfcb05365645a","modified":1465107134397},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1465107134516},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1465107134417},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1465107134518},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1465107134523},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1465107134528},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1465107134457},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1465107134526},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1465107134460},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1465107134533},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1465107134462},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1465107134459},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1465107134464},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1465107134465},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"c368f1533053d4cffdf0ad982603271400b08e33","modified":1465107134470},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1465107134478},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1465107134484},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1465107134482},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1465107134487},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1465107134486},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1465107134491},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1465107134495},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1465107134493},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1465107134501},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1465107134489},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1465107134506},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1465107134511},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1465107134421},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1465107134426},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1465107134422},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1465107134429},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1465107134509},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1465107134427},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1465107134439},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1465107134437},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1465107134431},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1465107134504},{"_id":"source/images/6948382.jpg","hash":"2b07b699d9e1b258295daca7583487f6f8581d0d","modified":1466313032923},{"_id":"public/2016/06/16/关于Java单例模式/index.html","hash":"cbc3a1f02233f0c2ea5523fb031c49f90264445a","modified":1466313181010},{"_id":"public/2016/06/10/DatePickerDialog-TimePickerDialog在某些机型上会连续返回两次结果/index.html","hash":"a6767b122cd33b3a117453dd1e848e5ff8d1651b","modified":1466313181016},{"_id":"public/2016/06/10/首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用/index.html","hash":"a4bd08a2752b42d6a9144f851daa9aabbaf95f83","modified":1466313181017},{"_id":"public/archives/index.html","hash":"efd634b9686ecb8f4690c4e14764e39140677b2e","modified":1466313181018},{"_id":"public/categories/Android/index.html","hash":"5ffc6a32e50236bc899965854219e692a203699a","modified":1466313181018},{"_id":"public/archives/2016/index.html","hash":"3b10e0fa3cb9dc76f53c9a1afaacfd9c2ee00a95","modified":1466313181018},{"_id":"public/archives/2016/06/index.html","hash":"b6e1f6eba17880b4aca61ef2c64fcc37bb6f813c","modified":1466313181018},{"_id":"public/index.html","hash":"0b857bf8f505e0a1730f37bdad540e5b627e2b29","modified":1466313181018},{"_id":"public/2016/06/05/HandlerThread-Handler-Thread/index.html","hash":"b7f3ea07fc29b178ef0df8461ce5403dcc19309a","modified":1466313181018},{"_id":"public/2016/06/19/Broadcast广播/index.html","hash":"da24fd516ffe5aca4bf1114291d1543eb46fe8b3","modified":1466313181020},{"_id":"public/images/6948382.jpg","hash":"2b07b699d9e1b258295daca7583487f6f8581d0d","modified":1466313181023}],"Category":[{"name":"Android","_id":"cipm4cr9v0002doucwtg9hbkk"}],"Data":[],"Page":[],"Post":[{"title":"Broadcast广播","date":"2016-06-19T04:52:38.000Z","_content":"\n![](/images/6948382.jpg)\n\nBroadcast包括两个概念，广播发送者和广播接收者(Receiver)，这里的广播实际就是指 Intent，程序可以自己发送广播自己接收，也可以接受系统或其他应用的广播或是发送广播给其他应用程序。\n发送者可以通过类似[Context.sendBroadcast()](http://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)接口发送广播，接收者通过[Context.registerReceiver()](http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter))动态注册或在 AndroidManifest.xml 文件中通过 <receiver> 标签静态注册。注册完成后，当发送者发送某个广播时系统会将发送的广播(Intent)与系统中所有注册的符合条件的接收者(Receiver)的 IntentFilter 进行匹配，若匹配成功则执行相应接收者的 onReceive 函数。\n\n<!--more-->\n\n## 广播的接收\n自定义广播接收器需要继承基类`BroadcastReceiver`或`WakefulBroadcastReceiver`，并实现抽象方法`onReceive(Context context, Intent intent)`。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在 UI 线程，因此，`onReceive()`方法中不能执行太耗时的操作。否则将因此 ANR。\n> **BroadcastReceiver**：不会保证CPU的持续工作。当你执行长时间的操作时，CPU可能会在中途陷入休眠。\n>**WakefulBroadcastReceiver**：保证CPU持续工作直到操作完成。\n[BroadcastReceiver Vs WakefulBroadcastReceiver](http://stackoverflow.com/questions/26380534/broadcastreceiver-vs-wakefulbroadcastreceiver)\n\n* 继承 BroadcastReceiver\n```java\npublic class CustomBroadcastReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"CustomBroadcastReceiver\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //TODO\n        Log.i(TAG, \"receive broadcast\");\n    }\n}\n```\n* 继承 WakefulBroadcastReceiver\n```java\npublic class CustomBroadcastReceiver extends WakefulBroadcastReceiver {\n\n    private static final String TAG = \"CustomBroadcastReceiver\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //TODO\n        Log.i(TAG, \"receive broadcast\");\n    }\n}\n```\n\n## 广播的注册\n广播的注册分为**动态注册**和**静态注册**。\n* **对bindService的调用**，<receiver>注册的广播，在onReceive结束后广播即不存在，所以不能在其中给自己异步传递结果，如bindService而只能使用startService，如果想跟service交互可使用peekService。\n* **手动控制**。registerReceiver为动态注册，自己可以手动注册或是取消注册；<receiver>标签为静态注册，由系统开机时自动扫描注册，所以无法手动控制，开机一直运行中。\n* **资源消耗不同**。registerReceiver可以手动控制，所以适当的注册和取消注册能节省系统资源，<receiver>标签系统开机后一直有效。\n* **有效期不同**。通过registerReceiver注册的BroadcastReceiver在对其进行注册的Context对象\"销毁\"了或者调用了unregisterReceiver方法时也就失效了，而通过<receiver>标签注册的BroadcastReceiver只要应用程序没有被删除就一直有效。\n* **对registerReceiver函数的调用许可不同**。通过registerReceiver注册的BroadcastReceiver在其onReceive函数中可以再次调用某个Context的registerReceiver函数，而通过<receiver>标签注册的BroadcastReceiver不允许再调用某个Context的registerReceiver函数 。\n* **使用情况不同**。对于自己发送和接受的广播可以通过registerReceiver注册，对于系统常用广播的接收通常用<receiver>标签注册。\n* 在 Android 3.1/API level 11 之前，静态注册的广播接收器即使在APP退出的情况下依然可以接收到广播。\n但是从 3.1 之后就不成立了。原因在于 Intent 与广播相关的 flag 增加了参数：FLAG_INCLUDE_STOPPED_PACKAGES 和 FLAG_EXCLUDE_STOPPED_PACKAGES。\n\n> FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出）\n> FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包\n\n自 3.1 开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。\n对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。\n但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。\n对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。\n在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。\n```java\nIntent intent = new Intent();\nintent.setAction(BROADCAST_ACTION);\nintent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES); \nsendBroadcast(intent);\n```\n\n### 动态注册\n代码中调用 Context.registerReceiver() 方法动态注册 BroadcastReceiver。\n在 Context 的实例被销毁时，调用 Context.unregisterReceiver() 解除注册的 BroadcastReceiver。\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    private static final String ACTION = \"com.test.action\";\n\n    private CustomBroadcastReceiver mCustomBroadcastReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mCustomBroadcastReceiver = new CustomBroadcastReceiver();\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(ACTION);\n\n        registerReceiver(mCustomBroadcastReceiver, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        unregisterReceiver(mCustomBroadcastReceiver);\n        super.onDestroy();\n    }\n}\n```\n### 静态注册\n在 AndroidManifest.xml 文件中进行注册。\n```java\n<receiver android:enabled=[\"true\" | \"false\"]\n\tandroid:exported=[\"true\" | \"false\"]\n\tandroid:icon=\"drawable resource\"\n\tandroid:label=\"string resource\"\n\tandroid:name=\"string\"\n\tandroid:permission=\"string\"\n\tandroid:process=\"string\" >\n\t<intent-filter>\n\t\t<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n\t\t<action android:name=\"com.test.action\" />\n\t</intent-filter>\n</receiver>\n```\nandroid:exported  —— 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；\nandroid:name  —— 此broadcastReceiver类名；\nandroid:permission  ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；\nandroid:process  —— broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）\nintent-filter —— 指定此广播接收器将用于接收特定的广播类型。\n广播的类型既可以是系统广播，比如`<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />`表示网络变化；也可以是自定义广播`<action android:name=\"com.test.action\" />`。\n\n## 广播的发送 \n广播根据发送方式的不同，可以分为**普通广播**,**有序广播**和**粘性广播**。\n\n广播实际发送的是意图（Intent），通过Action属性与Receiver匹配。\n如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。\nsetAction(...)对应BroadcastReceiver中的intent-Filter中的action。\n```java\nIntent intent = new Intent();\nintent.setAction(BROADCAST_ACTION);\n```\n* 普通广播\n普通的广播是不在意顺序的，最简单的理解是同时可以收到这个广播。如果应用是动态注册这个广播的，且广播发送时这个进程还活着，那么当然可以并发的把广播尽快地传送出去是最好的。\n但是，如果是通过AndroidManifest.xml静态注册的情况，也就是说这个广播首先要把一个进程启动起来，这时并发启动很多进程就是个问题了。Android目前的做法是，对这种静态的广播接收者，自动按有序广播的方式来串行处理。但是这对应用是透明的，应用不能假设系统已经把静态的无序广播当成有序广播来处理。\n```java\nContext.sendBroadcast(Intent intent);\nContext.sendBroadcast(Intent intent, String receiverPermission);\n```\n发送给特定的用户\n```java\nContext.sendBroadcastAsUser(Intent intent, UserHandle user);\nContext.sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);\n```\n* 有序广播\n有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, ...)。\n对于有序广播，其主要特点总结如下：\n\n* 多个具有当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。\n* 先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。\n有序广播因为要处理消息的处理结果，所以要复杂一些。\n\n```java\nsendOrderedBroadcast(Intent intent, String receiverPermission, \n\t\tBroadcastReceiver resultReceiver, Handler scheduler, int initialCode, \n\t\tString initialData, Bundle initialExtras);\n```\n如果只是想让广播可以按优先级来收取，并不在意处理的结果，可以用下面的版本：\n```java\nsendOrderedBroadcast(Intent intent, String receiverPermission);\n```\n同样，在多用户环境下，也可以选择给哪个用户发广播：\n```java\nsendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, \n                BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, \n                String initialData, Bundle initialExtras);\n```\n* 粘性广播\n从Android 5.0(API 21)开始，因为安全性的问题，官方已经正式废弃了粘性广播。\n在这里还是稍作介绍：\n广播已经发出，但是没有接收器与广播匹配。或者在广播发出之后，广播接收器才注册。此时，广播接收器就无法接收广播。\nAndroid引入了StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完Receiver后就可以继续使用刚才的广播。如果在接收者注册完成前发送了多条相同Action的粘性广播，注册完成后只会收到一条该Action的广播，并且消息内容是最后一次广播内容。\n系统网络状态的改变发送的广播就是粘性广播。\n粘性广播通过Context的[sendStickyBroadcast(Intent)](http://developer.android.com/reference/android/content/Context.html#sendStickyBroadcast(android.content.Intent))接口发送，需要添加权限`<uses-permission android:name=\"android.permission.BROADCAST_STICKY\"/>`\n也可以通过Context的[removeStickyBroadcast](http://developer.android.com/reference/android/content/Context.html#removeStickyBroadcast(android.content.Intent))([Intent](http://developer.android.com/reference/android/content/Intent.html))接口移除缓存的粘性广播。\n\n## 本地广播LocalBroadcastManager\n\nLocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。\n* 发送广播\n```java\nLocalBroadcastManager.getInstance(context).sendBroadcast(Intent);\n```\n* 注册广播\n```java\nLocalBroadcastManager.getInstance(context).registerReceiver(BroadcastReceiver, IntentFilter);\n```\n* 解除广播 \n```java \nLocalBroadcastManager.getInstance(context).unregisterReceiver(BroadcastReceiver);\n```\n其他同普通广播。\n\n## 生命周期\nBroadcastReceiver**在onReceive函数执行结束后即表示生命周期结束**，所以不适合在onReceive中做绑定服务操作，结束后若某个进程只含有该BroadcastReceiver，则优先级将降低可能被系统回收，所以**BroadcastReceiver中不适合做一些异步操作**，如新建线程下载数据，BroadcastReceiver结束后可能在异步操作完成前进程已经被系统kill。\n同时由于ANR限制BroadcastReceiver的onReceive函数必须在10秒内完成，而且onReceive默认会在主线程中执行，所以**BroadcastReceiver中不适合做一些耗时操作**，对于耗时操作需要交给service处理，比如网络或数据库耗时操作、对话框的显示(因为现实时间可能超时，用Notification代替)。\n\n## 安全性\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：\n* 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口**在发送广播时指定接收者必须具备的permission**。或通过Intent.setPackage设置广播仅对某个程序有效。\n \n* 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口**指定发送者必须具备的permission**，对于静态注册的广播可以通过**android:exported=\"false\"属性**表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n \n* 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中\n\n## 参考\n[Android BroadcastReceiver介绍](http://www.cnblogs.com/trinea/archive/2012/11/09/2763182.html)\n[Android总结篇系列：Android广播机制](http://www.cnblogs.com/lwbqqyumidi/p/4168017.html)\n[说说Android的广播(1) - 普通广播,有序广播和粘性广播](https://yq.aliyun.com/articles/53919)\n","source":"_posts/Broadcast广播.md","raw":"---\ntitle: Broadcast广播\ndate: 2016-06-19 12:52:38\ncategories: Android\ntags:\n---\n\n![](/images/6948382.jpg)\n\nBroadcast包括两个概念，广播发送者和广播接收者(Receiver)，这里的广播实际就是指 Intent，程序可以自己发送广播自己接收，也可以接受系统或其他应用的广播或是发送广播给其他应用程序。\n发送者可以通过类似[Context.sendBroadcast()](http://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent)接口发送广播，接收者通过[Context.registerReceiver()](http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter))动态注册或在 AndroidManifest.xml 文件中通过 <receiver> 标签静态注册。注册完成后，当发送者发送某个广播时系统会将发送的广播(Intent)与系统中所有注册的符合条件的接收者(Receiver)的 IntentFilter 进行匹配，若匹配成功则执行相应接收者的 onReceive 函数。\n\n<!--more-->\n\n## 广播的接收\n自定义广播接收器需要继承基类`BroadcastReceiver`或`WakefulBroadcastReceiver`，并实现抽象方法`onReceive(Context context, Intent intent)`。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在 UI 线程，因此，`onReceive()`方法中不能执行太耗时的操作。否则将因此 ANR。\n> **BroadcastReceiver**：不会保证CPU的持续工作。当你执行长时间的操作时，CPU可能会在中途陷入休眠。\n>**WakefulBroadcastReceiver**：保证CPU持续工作直到操作完成。\n[BroadcastReceiver Vs WakefulBroadcastReceiver](http://stackoverflow.com/questions/26380534/broadcastreceiver-vs-wakefulbroadcastreceiver)\n\n* 继承 BroadcastReceiver\n```java\npublic class CustomBroadcastReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"CustomBroadcastReceiver\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //TODO\n        Log.i(TAG, \"receive broadcast\");\n    }\n}\n```\n* 继承 WakefulBroadcastReceiver\n```java\npublic class CustomBroadcastReceiver extends WakefulBroadcastReceiver {\n\n    private static final String TAG = \"CustomBroadcastReceiver\";\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        //TODO\n        Log.i(TAG, \"receive broadcast\");\n    }\n}\n```\n\n## 广播的注册\n广播的注册分为**动态注册**和**静态注册**。\n* **对bindService的调用**，<receiver>注册的广播，在onReceive结束后广播即不存在，所以不能在其中给自己异步传递结果，如bindService而只能使用startService，如果想跟service交互可使用peekService。\n* **手动控制**。registerReceiver为动态注册，自己可以手动注册或是取消注册；<receiver>标签为静态注册，由系统开机时自动扫描注册，所以无法手动控制，开机一直运行中。\n* **资源消耗不同**。registerReceiver可以手动控制，所以适当的注册和取消注册能节省系统资源，<receiver>标签系统开机后一直有效。\n* **有效期不同**。通过registerReceiver注册的BroadcastReceiver在对其进行注册的Context对象\"销毁\"了或者调用了unregisterReceiver方法时也就失效了，而通过<receiver>标签注册的BroadcastReceiver只要应用程序没有被删除就一直有效。\n* **对registerReceiver函数的调用许可不同**。通过registerReceiver注册的BroadcastReceiver在其onReceive函数中可以再次调用某个Context的registerReceiver函数，而通过<receiver>标签注册的BroadcastReceiver不允许再调用某个Context的registerReceiver函数 。\n* **使用情况不同**。对于自己发送和接受的广播可以通过registerReceiver注册，对于系统常用广播的接收通常用<receiver>标签注册。\n* 在 Android 3.1/API level 11 之前，静态注册的广播接收器即使在APP退出的情况下依然可以接收到广播。\n但是从 3.1 之后就不成立了。原因在于 Intent 与广播相关的 flag 增加了参数：FLAG_INCLUDE_STOPPED_PACKAGES 和 FLAG_EXCLUDE_STOPPED_PACKAGES。\n\n> FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出）\n> FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包\n\n自 3.1 开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。\n对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。\n但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。\n对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。\n在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。\n```java\nIntent intent = new Intent();\nintent.setAction(BROADCAST_ACTION);\nintent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES); \nsendBroadcast(intent);\n```\n\n### 动态注册\n代码中调用 Context.registerReceiver() 方法动态注册 BroadcastReceiver。\n在 Context 的实例被销毁时，调用 Context.unregisterReceiver() 解除注册的 BroadcastReceiver。\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    private static final String ACTION = \"com.test.action\";\n\n    private CustomBroadcastReceiver mCustomBroadcastReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        mCustomBroadcastReceiver = new CustomBroadcastReceiver();\n\n        IntentFilter intentFilter = new IntentFilter();\n        intentFilter.addAction(ACTION);\n\n        registerReceiver(mCustomBroadcastReceiver, intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        unregisterReceiver(mCustomBroadcastReceiver);\n        super.onDestroy();\n    }\n}\n```\n### 静态注册\n在 AndroidManifest.xml 文件中进行注册。\n```java\n<receiver android:enabled=[\"true\" | \"false\"]\n\tandroid:exported=[\"true\" | \"false\"]\n\tandroid:icon=\"drawable resource\"\n\tandroid:label=\"string resource\"\n\tandroid:name=\"string\"\n\tandroid:permission=\"string\"\n\tandroid:process=\"string\" >\n\t<intent-filter>\n\t\t<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n\t\t<action android:name=\"com.test.action\" />\n\t</intent-filter>\n</receiver>\n```\nandroid:exported  —— 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；\nandroid:name  —— 此broadcastReceiver类名；\nandroid:permission  ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；\nandroid:process  —— broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）\nintent-filter —— 指定此广播接收器将用于接收特定的广播类型。\n广播的类型既可以是系统广播，比如`<action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />`表示网络变化；也可以是自定义广播`<action android:name=\"com.test.action\" />`。\n\n## 广播的发送 \n广播根据发送方式的不同，可以分为**普通广播**,**有序广播**和**粘性广播**。\n\n广播实际发送的是意图（Intent），通过Action属性与Receiver匹配。\n如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。\nsetAction(...)对应BroadcastReceiver中的intent-Filter中的action。\n```java\nIntent intent = new Intent();\nintent.setAction(BROADCAST_ACTION);\n```\n* 普通广播\n普通的广播是不在意顺序的，最简单的理解是同时可以收到这个广播。如果应用是动态注册这个广播的，且广播发送时这个进程还活着，那么当然可以并发的把广播尽快地传送出去是最好的。\n但是，如果是通过AndroidManifest.xml静态注册的情况，也就是说这个广播首先要把一个进程启动起来，这时并发启动很多进程就是个问题了。Android目前的做法是，对这种静态的广播接收者，自动按有序广播的方式来串行处理。但是这对应用是透明的，应用不能假设系统已经把静态的无序广播当成有序广播来处理。\n```java\nContext.sendBroadcast(Intent intent);\nContext.sendBroadcast(Intent intent, String receiverPermission);\n```\n发送给特定的用户\n```java\nContext.sendBroadcastAsUser(Intent intent, UserHandle user);\nContext.sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);\n```\n* 有序广播\n有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, ...)。\n对于有序广播，其主要特点总结如下：\n\n* 多个具有当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。\n* 先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。\n有序广播因为要处理消息的处理结果，所以要复杂一些。\n\n```java\nsendOrderedBroadcast(Intent intent, String receiverPermission, \n\t\tBroadcastReceiver resultReceiver, Handler scheduler, int initialCode, \n\t\tString initialData, Bundle initialExtras);\n```\n如果只是想让广播可以按优先级来收取，并不在意处理的结果，可以用下面的版本：\n```java\nsendOrderedBroadcast(Intent intent, String receiverPermission);\n```\n同样，在多用户环境下，也可以选择给哪个用户发广播：\n```java\nsendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, \n                BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, \n                String initialData, Bundle initialExtras);\n```\n* 粘性广播\n从Android 5.0(API 21)开始，因为安全性的问题，官方已经正式废弃了粘性广播。\n在这里还是稍作介绍：\n广播已经发出，但是没有接收器与广播匹配。或者在广播发出之后，广播接收器才注册。此时，广播接收器就无法接收广播。\nAndroid引入了StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完Receiver后就可以继续使用刚才的广播。如果在接收者注册完成前发送了多条相同Action的粘性广播，注册完成后只会收到一条该Action的广播，并且消息内容是最后一次广播内容。\n系统网络状态的改变发送的广播就是粘性广播。\n粘性广播通过Context的[sendStickyBroadcast(Intent)](http://developer.android.com/reference/android/content/Context.html#sendStickyBroadcast(android.content.Intent))接口发送，需要添加权限`<uses-permission android:name=\"android.permission.BROADCAST_STICKY\"/>`\n也可以通过Context的[removeStickyBroadcast](http://developer.android.com/reference/android/content/Context.html#removeStickyBroadcast(android.content.Intent))([Intent](http://developer.android.com/reference/android/content/Intent.html))接口移除缓存的粘性广播。\n\n## 本地广播LocalBroadcastManager\n\nLocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。\n* 发送广播\n```java\nLocalBroadcastManager.getInstance(context).sendBroadcast(Intent);\n```\n* 注册广播\n```java\nLocalBroadcastManager.getInstance(context).registerReceiver(BroadcastReceiver, IntentFilter);\n```\n* 解除广播 \n```java \nLocalBroadcastManager.getInstance(context).unregisterReceiver(BroadcastReceiver);\n```\n其他同普通广播。\n\n## 生命周期\nBroadcastReceiver**在onReceive函数执行结束后即表示生命周期结束**，所以不适合在onReceive中做绑定服务操作，结束后若某个进程只含有该BroadcastReceiver，则优先级将降低可能被系统回收，所以**BroadcastReceiver中不适合做一些异步操作**，如新建线程下载数据，BroadcastReceiver结束后可能在异步操作完成前进程已经被系统kill。\n同时由于ANR限制BroadcastReceiver的onReceive函数必须在10秒内完成，而且onReceive默认会在主线程中执行，所以**BroadcastReceiver中不适合做一些耗时操作**，对于耗时操作需要交给service处理，比如网络或数据库耗时操作、对话框的显示(因为现实时间可能超时，用Notification代替)。\n\n## 安全性\nBroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：\n* 当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口**在发送广播时指定接收者必须具备的permission**。或通过Intent.setPackage设置广播仅对某个程序有效。\n \n* 当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口**指定发送者必须具备的permission**，对于静态注册的广播可以通过**android:exported=\"false\"属性**表示接收者对外部应用程序不可用，即不接受来自外部的广播。\n \n* 上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中\n\n## 参考\n[Android BroadcastReceiver介绍](http://www.cnblogs.com/trinea/archive/2012/11/09/2763182.html)\n[Android总结篇系列：Android广播机制](http://www.cnblogs.com/lwbqqyumidi/p/4168017.html)\n[说说Android的广播(1) - 普通广播,有序广播和粘性广播](https://yq.aliyun.com/articles/53919)\n","slug":"Broadcast广播","published":1,"updated":"2016-06-19T05:11:24.133Z","_id":"cipm4cr9p0000doucfsgg6got","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/images/6948382.jpg\" alt=\"\"></p>\n<p>Broadcast包括两个概念，广播发送者和广播接收者(Receiver)，这里的广播实际就是指 Intent，程序可以自己发送广播自己接收，也可以接受系统或其他应用的广播或是发送广播给其他应用程序。<br>发送者可以通过类似<a href=\"http://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent\" target=\"_blank\" rel=\"external\">Context.sendBroadcast()</a>接口发送广播，接收者通过<a href=\"http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter\" target=\"_blank\" rel=\"external\">Context.registerReceiver()</a>)动态注册或在 AndroidManifest.xml 文件中通过 <receiver> 标签静态注册。注册完成后，当发送者发送某个广播时系统会将发送的广播(Intent)与系统中所有注册的符合条件的接收者(Receiver)的 IntentFilter 进行匹配，若匹配成功则执行相应接收者的 onReceive 函数。</receiver></p>\n<a id=\"more\"></a>\n<h2 id=\"广播的接收\"><a href=\"#广播的接收\" class=\"headerlink\" title=\"广播的接收\"></a>广播的接收</h2><p>自定义广播接收器需要继承基类<code>BroadcastReceiver</code>或<code>WakefulBroadcastReceiver</code>，并实现抽象方法<code>onReceive(Context context, Intent intent)</code>。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在 UI 线程，因此，<code>onReceive()</code>方法中不能执行太耗时的操作。否则将因此 ANR。</p>\n<blockquote>\n<p><strong>BroadcastReceiver</strong>：不会保证CPU的持续工作。当你执行长时间的操作时，CPU可能会在中途陷入休眠。<br><strong>WakefulBroadcastReceiver</strong>：保证CPU持续工作直到操作完成。<br><a href=\"http://stackoverflow.com/questions/26380534/broadcastreceiver-vs-wakefulbroadcastreceiver\" target=\"_blank\" rel=\"external\">BroadcastReceiver Vs WakefulBroadcastReceiver</a></p>\n</blockquote>\n<ul>\n<li><p>继承 BroadcastReceiver</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"CustomBroadcastReceiver\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO</span></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"receive broadcast\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>继承 WakefulBroadcastReceiver</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">WakefulBroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"CustomBroadcastReceiver\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO</span></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"receive broadcast\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"广播的注册\"><a href=\"#广播的注册\" class=\"headerlink\" title=\"广播的注册\"></a>广播的注册</h2><p>广播的注册分为<strong>动态注册</strong>和<strong>静态注册</strong>。</p>\n<ul>\n<li><strong>对bindService的调用</strong>，<receiver>注册的广播，在onReceive结束后广播即不存在，所以不能在其中给自己异步传递结果，如bindService而只能使用startService，如果想跟service交互可使用peekService。</receiver></li>\n<li><strong>手动控制</strong>。registerReceiver为动态注册，自己可以手动注册或是取消注册；<receiver>标签为静态注册，由系统开机时自动扫描注册，所以无法手动控制，开机一直运行中。</receiver></li>\n<li><strong>资源消耗不同</strong>。registerReceiver可以手动控制，所以适当的注册和取消注册能节省系统资源，<receiver>标签系统开机后一直有效。</receiver></li>\n<li><strong>有效期不同</strong>。通过registerReceiver注册的BroadcastReceiver在对其进行注册的Context对象”销毁”了或者调用了unregisterReceiver方法时也就失效了，而通过<receiver>标签注册的BroadcastReceiver只要应用程序没有被删除就一直有效。</receiver></li>\n<li><strong>对registerReceiver函数的调用许可不同</strong>。通过registerReceiver注册的BroadcastReceiver在其onReceive函数中可以再次调用某个Context的registerReceiver函数，而通过<receiver>标签注册的BroadcastReceiver不允许再调用某个Context的registerReceiver函数 。</receiver></li>\n<li><strong>使用情况不同</strong>。对于自己发送和接受的广播可以通过registerReceiver注册，对于系统常用广播的接收通常用<receiver>标签注册。</receiver></li>\n<li>在 Android 3.1/API level 11 之前，静态注册的广播接收器即使在APP退出的情况下依然可以接收到广播。<br>但是从 3.1 之后就不成立了。原因在于 Intent 与广播相关的 flag 增加了参数：FLAG_INCLUDE_STOPPED_PACKAGES 和 FLAG_EXCLUDE_STOPPED_PACKAGES。</li>\n</ul>\n<blockquote>\n<p>FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出）<br>FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包</p>\n</blockquote>\n<p>自 3.1 开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。<br>对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。<br>但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。<br>对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。<br>在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(BROADCAST_ACTION);</span><br><span class=\"line\">intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES); </span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动态注册\"><a href=\"#动态注册\" class=\"headerlink\" title=\"动态注册\"></a>动态注册</h3><p>代码中调用 Context.registerReceiver() 方法动态注册 BroadcastReceiver。<br>在 Context 的实例被销毁时，调用 Context.unregisterReceiver() 解除注册的 BroadcastReceiver。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ACTION = <span class=\"string\">\"com.test.action\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CustomBroadcastReceiver mCustomBroadcastReceiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        mCustomBroadcastReceiver = <span class=\"keyword\">new</span> CustomBroadcastReceiver();</span><br><span class=\"line\"></span><br><span class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\">        intentFilter.addAction(ACTION);</span><br><span class=\"line\"></span><br><span class=\"line\">        registerReceiver(mCustomBroadcastReceiver, intentFilter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        unregisterReceiver(mCustomBroadcastReceiver);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"静态注册\"><a href=\"#静态注册\" class=\"headerlink\" title=\"静态注册\"></a>静态注册</h3><p>在 AndroidManifest.xml 文件中进行注册。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:enabled=[\"true\" | \"false\"]</span><br><span class=\"line\">\tandroid:exported=[\"true\" | \"false\"]</span><br><span class=\"line\">\tandroid:icon=\"drawable resource\"</span><br><span class=\"line\">\tandroid:label=\"string resource\"</span><br><span class=\"line\">\tandroid:name=\"string\"</span><br><span class=\"line\">\tandroid:permission=\"string\"</span><br><span class=\"line\">\tandroid:process=\"string\" &gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=\"com.test.action\" /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p>\n<p>android:exported  —— 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；<br>android:name  —— 此broadcastReceiver类名；<br>android:permission  ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；<br>android:process  —— broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）<br>intent-filter —— 指定此广播接收器将用于接收特定的广播类型。<br>广播的类型既可以是系统广播，比如<code>&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;</code>表示网络变化；也可以是自定义广播<code>&lt;action android:name=&quot;com.test.action&quot; /&gt;</code>。</p>\n<h2 id=\"广播的发送\"><a href=\"#广播的发送\" class=\"headerlink\" title=\"广播的发送\"></a>广播的发送</h2><p>广播根据发送方式的不同，可以分为<strong>普通广播</strong>,<strong>有序广播</strong>和<strong>粘性广播</strong>。</p>\n<p>广播实际发送的是意图（Intent），通过Action属性与Receiver匹配。<br>如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。<br>setAction(…)对应BroadcastReceiver中的intent-Filter中的action。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(BROADCAST_ACTION);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>普通广播<br>普通的广播是不在意顺序的，最简单的理解是同时可以收到这个广播。如果应用是动态注册这个广播的，且广播发送时这个进程还活着，那么当然可以并发的把广播尽快地传送出去是最好的。<br>但是，如果是通过AndroidManifest.xml静态注册的情况，也就是说这个广播首先要把一个进程启动起来，这时并发启动很多进程就是个问题了。Android目前的做法是，对这种静态的广播接收者，自动按有序广播的方式来串行处理。但是这对应用是透明的，应用不能假设系统已经把静态的无序广播当成有序广播来处理。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.sendBroadcast(Intent intent);</span><br><span class=\"line\">Context.sendBroadcast(Intent intent, String receiverPermission);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>发送给特定的用户<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.sendBroadcastAsUser(Intent intent, UserHandle user);</span><br><span class=\"line\">Context.sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>有序广播<br>有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。<br>对于有序广播，其主要特点总结如下：</p>\n</li>\n<li><p>多个具有当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。</p>\n</li>\n<li>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。<br>有序广播因为要处理消息的处理结果，所以要复杂一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(Intent intent, String receiverPermission, </span><br><span class=\"line\">\t\tBroadcastReceiver resultReceiver, Handler scheduler, <span class=\"keyword\">int</span> initialCode, </span><br><span class=\"line\">\t\tString initialData, Bundle initialExtras);</span><br></pre></td></tr></table></figure>\n<p>如果只是想让广播可以按优先级来收取，并不在意处理的结果，可以用下面的版本：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(Intent intent, String receiverPermission);</span><br></pre></td></tr></table></figure></p>\n<p>同样，在多用户环境下，也可以选择给哪个用户发广播：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, </span><br><span class=\"line\">                BroadcastReceiver resultReceiver, Handler scheduler, <span class=\"keyword\">int</span> initialCode, </span><br><span class=\"line\">                String initialData, Bundle initialExtras);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>粘性广播<br>从Android 5.0(API 21)开始，因为安全性的问题，官方已经正式废弃了粘性广播。<br>在这里还是稍作介绍：<br>广播已经发出，但是没有接收器与广播匹配。或者在广播发出之后，广播接收器才注册。此时，广播接收器就无法接收广播。<br>Android引入了StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完Receiver后就可以继续使用刚才的广播。如果在接收者注册完成前发送了多条相同Action的粘性广播，注册完成后只会收到一条该Action的广播，并且消息内容是最后一次广播内容。<br>系统网络状态的改变发送的广播就是粘性广播。<br>粘性广播通过Context的<a href=\"http://developer.android.com/reference/android/content/Context.html#sendStickyBroadcast(android.content.Intent\" target=\"_blank\" rel=\"external\">sendStickyBroadcast(Intent)</a>)接口发送，需要添加权限<code>&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt;</code><br>也可以通过Context的<a href=\"http://developer.android.com/reference/android/content/Context.html#removeStickyBroadcast(android.content.Intent\" target=\"_blank\" rel=\"external\">removeStickyBroadcast</a>)(<a href=\"http://developer.android.com/reference/android/content/Intent.html\" target=\"_blank\" rel=\"external\">Intent</a>)接口移除缓存的粘性广播。</li>\n</ul>\n<h2 id=\"本地广播LocalBroadcastManager\"><a href=\"#本地广播LocalBroadcastManager\" class=\"headerlink\" title=\"本地广播LocalBroadcastManager\"></a>本地广播LocalBroadcastManager</h2><p>LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。</p>\n<ul>\n<li><p>发送广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).sendBroadcast(Intent);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).registerReceiver(BroadcastReceiver, IntentFilter);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解除广播 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).unregisterReceiver(BroadcastReceiver);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其他同普通广播。</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>BroadcastReceiver<strong>在onReceive函数执行结束后即表示生命周期结束</strong>，所以不适合在onReceive中做绑定服务操作，结束后若某个进程只含有该BroadcastReceiver，则优先级将降低可能被系统回收，所以<strong>BroadcastReceiver中不适合做一些异步操作</strong>，如新建线程下载数据，BroadcastReceiver结束后可能在异步操作完成前进程已经被系统kill。<br>同时由于ANR限制BroadcastReceiver的onReceive函数必须在10秒内完成，而且onReceive默认会在主线程中执行，所以<strong>BroadcastReceiver中不适合做一些耗时操作</strong>，对于耗时操作需要交给service处理，比如网络或数据库耗时操作、对话框的显示(因为现实时间可能超时，用Notification代替)。</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：</p>\n<ul>\n<li><p>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口<strong>在发送广播时指定接收者必须具备的permission</strong>。或通过Intent.setPackage设置广播仅对某个程序有效。</p>\n</li>\n<li><p>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口<strong>指定发送者必须具备的permission</strong>，对于静态注册的广播可以通过<strong>android:exported=”false”属性</strong>表示接收者对外部应用程序不可用，即不接受来自外部的广播。</p>\n</li>\n<li><p>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/trinea/archive/2012/11/09/2763182.html\" target=\"_blank\" rel=\"external\">Android BroadcastReceiver介绍</a><br><a href=\"http://www.cnblogs.com/lwbqqyumidi/p/4168017.html\" target=\"_blank\" rel=\"external\">Android总结篇系列：Android广播机制</a><br><a href=\"https://yq.aliyun.com/articles/53919\" target=\"_blank\" rel=\"external\">说说Android的广播(1) - 普通广播,有序广播和粘性广播</a></p>\n","excerpt":"<p><img src=\"/images/6948382.jpg\" alt=\"\"></p>\n<p>Broadcast包括两个概念，广播发送者和广播接收者(Receiver)，这里的广播实际就是指 Intent，程序可以自己发送广播自己接收，也可以接受系统或其他应用的广播或是发送广播给其他应用程序。<br>发送者可以通过类似<a href=\"http://developer.android.com/reference/android/content/Context.html#sendBroadcast(android.content.Intent\">Context.sendBroadcast()</a>接口发送广播，接收者通过<a href=\"http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter\">Context.registerReceiver()</a>)动态注册或在 AndroidManifest.xml 文件中通过 <receiver> 标签静态注册。注册完成后，当发送者发送某个广播时系统会将发送的广播(Intent)与系统中所有注册的符合条件的接收者(Receiver)的 IntentFilter 进行匹配，若匹配成功则执行相应接收者的 onReceive 函数。</p>","more":"<h2 id=\"广播的接收\"><a href=\"#广播的接收\" class=\"headerlink\" title=\"广播的接收\"></a>广播的接收</h2><p>自定义广播接收器需要继承基类<code>BroadcastReceiver</code>或<code>WakefulBroadcastReceiver</code>，并实现抽象方法<code>onReceive(Context context, Intent intent)</code>。广播接收器接收到相应广播后，会自动回到onReceive(..)方法。默认情况下，广播接收器也是运行在 UI 线程，因此，<code>onReceive()</code>方法中不能执行太耗时的操作。否则将因此 ANR。</p>\n<blockquote>\n<p><strong>BroadcastReceiver</strong>：不会保证CPU的持续工作。当你执行长时间的操作时，CPU可能会在中途陷入休眠。<br><strong>WakefulBroadcastReceiver</strong>：保证CPU持续工作直到操作完成。<br><a href=\"http://stackoverflow.com/questions/26380534/broadcastreceiver-vs-wakefulbroadcastreceiver\">BroadcastReceiver Vs WakefulBroadcastReceiver</a></p>\n</blockquote>\n<ul>\n<li><p>继承 BroadcastReceiver</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">BroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"CustomBroadcastReceiver\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO</span></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"receive broadcast\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>继承 WakefulBroadcastReceiver</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomBroadcastReceiver</span> <span class=\"keyword\">extends</span> <span class=\"title\">WakefulBroadcastReceiver</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"CustomBroadcastReceiver\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onReceive</span><span class=\"params\">(Context context, Intent intent)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//TODO</span></span><br><span class=\"line\">        Log.i(TAG, <span class=\"string\">\"receive broadcast\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"广播的注册\"><a href=\"#广播的注册\" class=\"headerlink\" title=\"广播的注册\"></a>广播的注册</h2><p>广播的注册分为<strong>动态注册</strong>和<strong>静态注册</strong>。</p>\n<ul>\n<li><strong>对bindService的调用</strong>，<receiver>注册的广播，在onReceive结束后广播即不存在，所以不能在其中给自己异步传递结果，如bindService而只能使用startService，如果想跟service交互可使用peekService。</li>\n<li><strong>手动控制</strong>。registerReceiver为动态注册，自己可以手动注册或是取消注册；<receiver>标签为静态注册，由系统开机时自动扫描注册，所以无法手动控制，开机一直运行中。</li>\n<li><strong>资源消耗不同</strong>。registerReceiver可以手动控制，所以适当的注册和取消注册能节省系统资源，<receiver>标签系统开机后一直有效。</li>\n<li><strong>有效期不同</strong>。通过registerReceiver注册的BroadcastReceiver在对其进行注册的Context对象”销毁”了或者调用了unregisterReceiver方法时也就失效了，而通过<receiver>标签注册的BroadcastReceiver只要应用程序没有被删除就一直有效。</li>\n<li><strong>对registerReceiver函数的调用许可不同</strong>。通过registerReceiver注册的BroadcastReceiver在其onReceive函数中可以再次调用某个Context的registerReceiver函数，而通过<receiver>标签注册的BroadcastReceiver不允许再调用某个Context的registerReceiver函数 。</li>\n<li><strong>使用情况不同</strong>。对于自己发送和接受的广播可以通过registerReceiver注册，对于系统常用广播的接收通常用<receiver>标签注册。</li>\n<li>在 Android 3.1/API level 11 之前，静态注册的广播接收器即使在APP退出的情况下依然可以接收到广播。<br>但是从 3.1 之后就不成立了。原因在于 Intent 与广播相关的 flag 增加了参数：FLAG_INCLUDE_STOPPED_PACKAGES 和 FLAG_EXCLUDE_STOPPED_PACKAGES。</li>\n</ul>\n<blockquote>\n<p>FLAG_INCLUDE_STOPPED_PACKAGES：包含已经停止的包（停止：即包所在的进程已经退出）<br>FLAG_EXCLUDE_STOPPED_PACKAGES：不包含已经停止的包</p>\n</blockquote>\n<p>自 3.1 开始，系统本身则增加了对所有app当前是否处于运行状态的跟踪。在发送广播时，不管是什么广播类型，系统默认直接增加了值为FLAG_EXCLUDE_STOPPED_PACKAGES的flag，导致即使是静态注册的广播接收器，对于其所在进程已经退出的app，同样无法接收到广播。<br>对于系统广播，由于是系统内部直接发出，无法更改此intent flag值，因此，3.1开始对于静态注册的接收系统广播的BroadcastReceiver，如果App进程已经退出，将不能接收到广播。<br>但是对于自定义的广播，可以通过复写此flag为FLAG_INCLUDE_STOPPED_PACKAGES，使得静态注册的BroadcastReceiver，即使所在App进程已经退出，也能能接收到广播，并会启动应用进程，但此时的BroadcastReceiver是重新新建的。<br>对于动态注册类型的BroadcastReceiver，由于此注册和取消注册实在其他组件（如Activity）中进行，因此，不受此改变影响。<br>在3.1以前，相信不少app可能通过静态注册方式监听各种系统广播，以此进行一些业务上的处理（如即时app已经退出，仍然能接收到，可以启动service等..）,3.1后，静态注册接受广播方式的改变，将直接导致此类方案不再可行。于是，通过将Service与App本身设置成不同的进程已经成为实现此类需求的可行替代方案。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(BROADCAST_ACTION);</span><br><span class=\"line\">intent.addFlags(Intent.FLAG_INCLUDE_STOPPED_PACKAGES); </span><br><span class=\"line\">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"动态注册\"><a href=\"#动态注册\" class=\"headerlink\" title=\"动态注册\"></a>动态注册</h3><p>代码中调用 Context.registerReceiver() 方法动态注册 BroadcastReceiver。<br>在 Context 的实例被销毁时，调用 Context.unregisterReceiver() 解除注册的 BroadcastReceiver。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MainActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">AppCompatActivity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ACTION = <span class=\"string\">\"com.test.action\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CustomBroadcastReceiver mCustomBroadcastReceiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">        setContentView(R.layout.activity_main);</span><br><span class=\"line\"></span><br><span class=\"line\">        mCustomBroadcastReceiver = <span class=\"keyword\">new</span> CustomBroadcastReceiver();</span><br><span class=\"line\"></span><br><span class=\"line\">        IntentFilter intentFilter = <span class=\"keyword\">new</span> IntentFilter();</span><br><span class=\"line\">        intentFilter.addAction(ACTION);</span><br><span class=\"line\"></span><br><span class=\"line\">        registerReceiver(mCustomBroadcastReceiver, intentFilter);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        unregisterReceiver(mCustomBroadcastReceiver);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"静态注册\"><a href=\"#静态注册\" class=\"headerlink\" title=\"静态注册\"></a>静态注册</h3><p>在 AndroidManifest.xml 文件中进行注册。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;receiver android:enabled=[\"true\" | \"false\"]</span><br><span class=\"line\">\tandroid:exported=[\"true\" | \"false\"]</span><br><span class=\"line\">\tandroid:icon=\"drawable resource\"</span><br><span class=\"line\">\tandroid:label=\"string resource\"</span><br><span class=\"line\">\tandroid:name=\"string\"</span><br><span class=\"line\">\tandroid:permission=\"string\"</span><br><span class=\"line\">\tandroid:process=\"string\" &gt;</span><br><span class=\"line\">\t&lt;intent-filter&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /&gt;</span><br><span class=\"line\">\t\t&lt;action android:name=\"com.test.action\" /&gt;</span><br><span class=\"line\">\t&lt;/intent-filter&gt;</span><br><span class=\"line\">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure></p>\n<p>android:exported  —— 此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；<br>android:name  —— 此broadcastReceiver类名；<br>android:permission  ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；<br>android:process  —— broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）<br>intent-filter —— 指定此广播接收器将用于接收特定的广播类型。<br>广播的类型既可以是系统广播，比如<code>&lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot; /&gt;</code>表示网络变化；也可以是自定义广播<code>&lt;action android:name=&quot;com.test.action&quot; /&gt;</code>。</p>\n<h2 id=\"广播的发送\"><a href=\"#广播的发送\" class=\"headerlink\" title=\"广播的发送\"></a>广播的发送</h2><p>广播根据发送方式的不同，可以分为<strong>普通广播</strong>,<strong>有序广播</strong>和<strong>粘性广播</strong>。</p>\n<p>广播实际发送的是意图（Intent），通过Action属性与Receiver匹配。<br>如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。<br>setAction(…)对应BroadcastReceiver中的intent-Filter中的action。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent();</span><br><span class=\"line\">intent.setAction(BROADCAST_ACTION);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>普通广播<br>普通的广播是不在意顺序的，最简单的理解是同时可以收到这个广播。如果应用是动态注册这个广播的，且广播发送时这个进程还活着，那么当然可以并发的把广播尽快地传送出去是最好的。<br>但是，如果是通过AndroidManifest.xml静态注册的情况，也就是说这个广播首先要把一个进程启动起来，这时并发启动很多进程就是个问题了。Android目前的做法是，对这种静态的广播接收者，自动按有序广播的方式来串行处理。但是这对应用是透明的，应用不能假设系统已经把静态的无序广播当成有序广播来处理。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.sendBroadcast(Intent intent);</span><br><span class=\"line\">Context.sendBroadcast(Intent intent, String receiverPermission);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>发送给特定的用户<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Context.sendBroadcastAsUser(Intent intent, UserHandle user);</span><br><span class=\"line\">Context.sendBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>有序广播<br>有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。<br>对于有序广播，其主要特点总结如下：</p>\n</li>\n<li><p>多个具有当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。</p>\n</li>\n<li>先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。<br>有序广播因为要处理消息的处理结果，所以要复杂一些。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(Intent intent, String receiverPermission, </span><br><span class=\"line\">\t\tBroadcastReceiver resultReceiver, Handler scheduler, <span class=\"keyword\">int</span> initialCode, </span><br><span class=\"line\">\t\tString initialData, Bundle initialExtras);</span><br></pre></td></tr></table></figure>\n<p>如果只是想让广播可以按优先级来收取，并不在意处理的结果，可以用下面的版本：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcast(Intent intent, String receiverPermission);</span><br></pre></td></tr></table></figure></p>\n<p>同样，在多用户环境下，也可以选择给哪个用户发广播：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, </span><br><span class=\"line\">                BroadcastReceiver resultReceiver, Handler scheduler, <span class=\"keyword\">int</span> initialCode, </span><br><span class=\"line\">                String initialData, Bundle initialExtras);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>粘性广播<br>从Android 5.0(API 21)开始，因为安全性的问题，官方已经正式废弃了粘性广播。<br>在这里还是稍作介绍：<br>广播已经发出，但是没有接收器与广播匹配。或者在广播发出之后，广播接收器才注册。此时，广播接收器就无法接收广播。<br>Android引入了StickyBroadcast，在广播发送结束后会保存刚刚发送的广播（Intent），这样当接收者注册完Receiver后就可以继续使用刚才的广播。如果在接收者注册完成前发送了多条相同Action的粘性广播，注册完成后只会收到一条该Action的广播，并且消息内容是最后一次广播内容。<br>系统网络状态的改变发送的广播就是粘性广播。<br>粘性广播通过Context的<a href=\"http://developer.android.com/reference/android/content/Context.html#sendStickyBroadcast(android.content.Intent\">sendStickyBroadcast(Intent)</a>)接口发送，需要添加权限<code>&lt;uses-permission android:name=&quot;android.permission.BROADCAST_STICKY&quot;/&gt;</code><br>也可以通过Context的<a href=\"http://developer.android.com/reference/android/content/Context.html#removeStickyBroadcast(android.content.Intent\">removeStickyBroadcast</a>)(<a href=\"http://developer.android.com/reference/android/content/Intent.html\">Intent</a>)接口移除缓存的粘性广播。</li>\n</ul>\n<h2 id=\"本地广播LocalBroadcastManager\"><a href=\"#本地广播LocalBroadcastManager\" class=\"headerlink\" title=\"本地广播LocalBroadcastManager\"></a>本地广播LocalBroadcastManager</h2><p>LocalBroadcastManager除了能解决BroadcastReceiver进程间安全性问题外，相对Context操作的BroadcastReceiver而言还具有更高的运行效率。</p>\n<ul>\n<li><p>发送广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).sendBroadcast(Intent);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>注册广播</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).registerReceiver(BroadcastReceiver, IntentFilter);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解除广播 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LocalBroadcastManager.getInstance(context).unregisterReceiver(BroadcastReceiver);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>其他同普通广播。</p>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><p>BroadcastReceiver<strong>在onReceive函数执行结束后即表示生命周期结束</strong>，所以不适合在onReceive中做绑定服务操作，结束后若某个进程只含有该BroadcastReceiver，则优先级将降低可能被系统回收，所以<strong>BroadcastReceiver中不适合做一些异步操作</strong>，如新建线程下载数据，BroadcastReceiver结束后可能在异步操作完成前进程已经被系统kill。<br>同时由于ANR限制BroadcastReceiver的onReceive函数必须在10秒内完成，而且onReceive默认会在主线程中执行，所以<strong>BroadcastReceiver中不适合做一些耗时操作</strong>，对于耗时操作需要交给service处理，比如网络或数据库耗时操作、对话框的显示(因为现实时间可能超时，用Notification代替)。</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><p>BroadcastReceiver的设计初衷就是从全局考虑的，可以方便应用程序和系统、应用程序之间、应用程序内的通信，所以对单个应用程序而言BroadcastReceiver是存在安全性问题的，相应问题及解决如下：</p>\n<ul>\n<li><p>当应用程序发送某个广播时系统会将发送的Intent与系统中所有注册的BroadcastReceiver的IntentFilter进行匹配，若匹配成功则执行相应的onReceive函数。可以通过类似sendBroadcast(Intent, String)的接口<strong>在发送广播时指定接收者必须具备的permission</strong>。或通过Intent.setPackage设置广播仅对某个程序有效。</p>\n</li>\n<li><p>当应用程序注册了某个广播时，即便设置了IntentFilter还是会接收到来自其他应用程序的广播进行匹配判断。对于动态注册的广播可以通过类似registerReceiver(BroadcastReceiver, IntentFilter, String, android.os.Handler)的接口<strong>指定发送者必须具备的permission</strong>，对于静态注册的广播可以通过<strong>android:exported=”false”属性</strong>表示接收者对外部应用程序不可用，即不接受来自外部的广播。</p>\n</li>\n<li><p>上面两个问题其实都可以通过LocalBroadcastManager来解决，LocalBroadcastManager只会将广播限定在当前应用程序中</p>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://www.cnblogs.com/trinea/archive/2012/11/09/2763182.html\">Android BroadcastReceiver介绍</a><br><a href=\"http://www.cnblogs.com/lwbqqyumidi/p/4168017.html\">Android总结篇系列：Android广播机制</a><br><a href=\"https://yq.aliyun.com/articles/53919\">说说Android的广播(1) - 普通广播,有序广播和粘性广播</a></p>"},{"title":"关于Java单例模式","date":"2016-06-16T14:20:20.000Z","_content":"\n单例模式其实是最容易理解的一种设计模式。\n单例模式应该保证在任何时候都只有一个实例，所以个人认为不能提供线程安全的单例模式其实根本不能算单例，很遗憾，甚至在教科书中你看到的都是这种非安全的单例。\n网上总结的单例应该有五种，懒汉，恶汉，双重校验锁，枚举和静态内部类。想了解更多请浏览**扩展阅读**\n这里只说明这两种，**静态内部类**和**枚举**。\n\n<!--more-->\n\n## 静态内部类\n```java\npublic class Singleton {  \n    private Singleton (){}  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    } \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。\n这种写法仍然使用 JVM 本身机制保证了线程安全问题；\n由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；\n同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n## 枚举\n```java\npublic enum Singleton{\n    INSTANCE;\n}\n```\n最简单的写法，但是如果是 Android，应该避免使用enum。\n用法同样比一般单例简单，通过 Singleton.INSTANCE 来调用实例。\n创建枚举默认就是线程安全的，所以不需要担心 double checked locking，而且还能防止反序列化导致重新创建新的对象。\n需要注意的是，java 1.5才加入 enum 特性。\n\n## 扩展阅读\n[如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)：对主要几种单例写法的整理，并分析其优缺点。\n[Java 单例真的写对了么?](http://www.race604.com/java-double-checked-singleton/)：分析了双重校验锁普遍存在的一种错误写法\n[深入理解Java内存模型（六）](http://www.infoq.com/cn/articles/java-memory-model-6)：关于 **final** 关键字的原理","source":"_posts/关于Java单例模式.md","raw":"---\ntitle: 关于Java单例模式\ndate: 2016-06-16 22:20:20\ncategories: Android\ntags:\n---\n\n单例模式其实是最容易理解的一种设计模式。\n单例模式应该保证在任何时候都只有一个实例，所以个人认为不能提供线程安全的单例模式其实根本不能算单例，很遗憾，甚至在教科书中你看到的都是这种非安全的单例。\n网上总结的单例应该有五种，懒汉，恶汉，双重校验锁，枚举和静态内部类。想了解更多请浏览**扩展阅读**\n这里只说明这两种，**静态内部类**和**枚举**。\n\n<!--more-->\n\n## 静态内部类\n```java\npublic class Singleton {  \n    private Singleton (){}  \n    private static class SingletonHolder {  \n        private static final Singleton INSTANCE = new Singleton();  \n    } \n    public static final Singleton getInstance() {  \n        return SingletonHolder.INSTANCE; \n    }  \n}\n```\n我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。\n这种写法仍然使用 JVM 本身机制保证了线程安全问题；\n由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；\n同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。\n\n## 枚举\n```java\npublic enum Singleton{\n    INSTANCE;\n}\n```\n最简单的写法，但是如果是 Android，应该避免使用enum。\n用法同样比一般单例简单，通过 Singleton.INSTANCE 来调用实例。\n创建枚举默认就是线程安全的，所以不需要担心 double checked locking，而且还能防止反序列化导致重新创建新的对象。\n需要注意的是，java 1.5才加入 enum 特性。\n\n## 扩展阅读\n[如何正确地写出单例模式](http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/)：对主要几种单例写法的整理，并分析其优缺点。\n[Java 单例真的写对了么?](http://www.race604.com/java-double-checked-singleton/)：分析了双重校验锁普遍存在的一种错误写法\n[深入理解Java内存模型（六）](http://www.infoq.com/cn/articles/java-memory-model-6)：关于 **final** 关键字的原理","slug":"关于Java单例模式","published":1,"updated":"2016-06-19T04:51:52.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipm4cr9t0001douc0adlafy3","content":"<p>单例模式其实是最容易理解的一种设计模式。<br>单例模式应该保证在任何时候都只有一个实例，所以个人认为不能提供线程安全的单例模式其实根本不能算单例，很遗憾，甚至在教科书中你看到的都是这种非安全的单例。<br>网上总结的单例应该有五种，懒汉，恶汉，双重校验锁，枚举和静态内部类。想了解更多请浏览<strong>扩展阅读</strong><br>这里只说明这两种，<strong>静态内部类</strong>和<strong>枚举</strong>。</p>\n<a id=\"more\"></a>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。<br>这种写法仍然使用 JVM 本身机制保证了线程安全问题；<br>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；<br>同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最简单的写法，但是如果是 Android，应该避免使用enum。<br>用法同样比一般单例简单，通过 Singleton.INSTANCE 来调用实例。<br>创建枚举默认就是线程安全的，所以不需要担心 double checked locking，而且还能防止反序列化导致重新创建新的对象。<br>需要注意的是，java 1.5才加入 enum 特性。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p><a href=\"http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/\" target=\"_blank\" rel=\"external\">如何正确地写出单例模式</a>：对主要几种单例写法的整理，并分析其优缺点。<br><a href=\"http://www.race604.com/java-double-checked-singleton/\" target=\"_blank\" rel=\"external\">Java 单例真的写对了么?</a>：分析了双重校验锁普遍存在的一种错误写法<br><a href=\"http://www.infoq.com/cn/articles/java-memory-model-6\" target=\"_blank\" rel=\"external\">深入理解Java内存模型（六）</a>：关于 <strong>final</strong> 关键字的原理</p>\n","excerpt":"<p>单例模式其实是最容易理解的一种设计模式。<br>单例模式应该保证在任何时候都只有一个实例，所以个人认为不能提供线程安全的单例模式其实根本不能算单例，很遗憾，甚至在教科书中你看到的都是这种非安全的单例。<br>网上总结的单例应该有五种，懒汉，恶汉，双重校验锁，枚举和静态内部类。想了解更多请浏览<strong>扩展阅读</strong><br>这里只说明这两种，<strong>静态内部类</strong>和<strong>枚举</strong>。</p>","more":"<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE; </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我比较倾向于使用静态内部类的方法，这种方法也是《Effective Java》上所推荐的。<br>这种写法仍然使用 JVM 本身机制保证了线程安全问题；<br>由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；<br>同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Singleton&#123;</span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最简单的写法，但是如果是 Android，应该避免使用enum。<br>用法同样比一般单例简单，通过 Singleton.INSTANCE 来调用实例。<br>创建枚举默认就是线程安全的，所以不需要担心 double checked locking，而且还能防止反序列化导致重新创建新的对象。<br>需要注意的是，java 1.5才加入 enum 特性。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><p><a href=\"http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/\">如何正确地写出单例模式</a>：对主要几种单例写法的整理，并分析其优缺点。<br><a href=\"http://www.race604.com/java-double-checked-singleton/\">Java 单例真的写对了么?</a>：分析了双重校验锁普遍存在的一种错误写法<br><a href=\"http://www.infoq.com/cn/articles/java-memory-model-6\">深入理解Java内存模型（六）</a>：关于 <strong>final</strong> 关键字的原理</p>"},{"title":"HandlerThread, Handler, Thread, Runnable","date":"2016-06-05T06:53:52.000Z","_content":"\n![](/images/ckxt0.jpg)\n\nHandler会关联一个单独的线程和消息队列。\nHandler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。\n如果要在其他线程执行，可以使用HandlerThread。\nHandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。\n\n<!--more-->\n\n# HandlerThread的使用\n\n```java\n//Handler handler = new Handler() {\n//...\n//}\nHandlerThread uIhandlerThread = new HandlerThread(\"update\");\nuIhandlerThread.start();\n//Handler UIhandler = new Handler(uIhandlerThread.getLooper());\nHandler uIhandler = new Handler(uIhandlerThread.getLooper(), new Callback() {\n\tpublic boolean handleMessage(Message msg) {\n\tBundle b = msg.getData();\n\tint age = b.getInt(\"age\");\n\tString name = b.getString(\"name\");\n\tSystem.out.println(\"age is \" + age + \", name is\" + name);\n\tSystem.out.println(\"Handler--->\" + Thread.currentThread().getId());\n\tSystem.out.println(\"handlerMessage\");\n\treturn true;\n\t}\n});\n```\n\n当要停止uIhandlerThread执行时用：\n```java\nif (uIhandlerThread != null) {\n\tpointThread.quit();\n}\n```\n\n# Handler的使用\n\n目前常使用的有两种用法，\n一种是自定义Handler，在handleMessage进行事件的处理， 这个Message可以是在其他线程中send的，或者在主线程中send。\n在线程中发送信息到主进程：\n## 1. 定义handler\n\n```java\npublic class MyHandler extends Handler {\n\t@Override\n\tpublic boolean handleMessage(Message msg) {\n\t\tswitch (msg.what){\n\t\tcase 1 :\n\t\t....\n\t\t}\n\t}\n}\nMyHandler myHandler = new MyHandler();\n```\n\n或者\n\n```java\nHandler myHandler = new Handler(new Callback() {\n\t// 参数也可以为（this.getMainLooper()，new Callback(){}）不写则默认为主进程的Looper\n\t@Override\n\tpublic boolean handleMessage(Message msg) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n});\n```\n\n## 2. 新建一个线程\n\n```java\nThread sender = new Thread(){\n\t@Override\n\tpublic void run() {\n\t\t....\n\t\t//Message msg = new Message();\n\t\tMessage msg = myHandler.obtainMessage(); //可以从handler中拿出message，省去了重新实例化的内存开销\n\t\t//myHandler.sendMessage(msg);\n\t\tmsg.sendToTarget();\n\t\t//myHandler.sendEmptyMessage(intWhat);\n\t}\n}\nsender.start();\n```\n\n在主线程中发信息到handler\n直接在主进程，不在线程中mHandler.sendMessage(msg);\n另一种为post一个线程进去，执行线程。直到线程退出或者是handler被removeCallbacks。\n定义一个线程Tread名为sender（不重复了）。\n然后执行，myHandler.post(sender);\n这样线程就在handler中执行。如果要停止线程的话：\n```java\nif(myHandler!=null) {\n\tmyHandler.removeCallbacks(senderObj);\n}\n```\n\n也可用一个Runnable来代替Thread\n\n```java\nRunnable r = new Runnable() {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n};\nmyHandler.post(r);\n```\n\n以上两种，是否使用handler的post来启动，差别在与是否开启新线程来执行处理。\n**使用post方法时，直接调用Thread或Runnable的run方法，所有处理都在主线程中进行，并没有开启定义的Thread或Runnable新的线程！！**\n\n# 关于Thread和Runnable的区别\n\nThread和Runnable是实现java多线程的两种方式，Thread是类，Runnable为接口，建议使用Runnable来实现多线程。\n如果让一个线程实现Runnable接口，那么当调用这个线程的对象开启多个线程时，可以让这些线程调用同一个变量；\n若这个线程是由继承Thread类而来，则要通过内部类来实现上述的功能，利用的就是内部类可任意访问外部类变量这个特性。（精辟！！）\n\n## 实现Runnable接口\n\n```java\npublic class ThreadTest {\n\tpublic static void main(String[] args) {\n\t\tMyThread mt=new MyThread();\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第一个线程\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第二个线程\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第三个线程\n\t\t//由于这三个线程是通过同一个对象mt开辟的，所以run()里方法访问的是同一个index\n\t}\n}\n```\n```java\n//实现Runnable接口\nclass MyThread implements Runnable {\n\tint index=0;\n\tpublic void run() {\n\t\tfor(;index<=200;)\n\t\tSystem.out.println(Thread.currentThread().getName()+\":\"+index++);\n\t}\n}\n```\n\n## 继承Thread\n\n```java\npublic class ThreadTest {\n\tpublic static void main(String[] args) {\n\t\tMyThread mt=new MyThread();\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第一个线程\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第二个线程\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第三个线程\n\t\t//由于这三个线程是通过同一个匿名对象来开辟的，所以run()里方法访问的是同一个index\n\t}\n}\n```\n```java\nclass MyThread {\n\tint index=0;\n\t//定义一个内部类，继承Thread\n\tprivate class InnerClass extends Thread {\n\t\tpublic void run() {\n\t\t\tfor(;index<=200;)\n\t\t\tSystem.out.println(getName()+\":\"+index++);\n\t\t}\n\t}\n\t//这个函数的作用是返回InnerClass的一个匿名对象\n\tThread getThread() {\n\t\treturn new InnerClass();\n\t}\n}\n// 这里有一个问题：如果内部类要访问一个外部变量或方法，那么这个变量或方法必须定义为final，但为什么这里的变量index不用定义为final就可以被内部类访问？\n```\n\n# Thread的使用\n\n```java\nThread sender = new Thread(){\n\t@Override\n\tpublic void run() {\n\t\t....\n\t}\n}\nsender.start();\n```\n\n线程的停止\n```java\nif (sender != null) {\n\t//sender.quit();\n\tsender.join(); // 执行完毕当前处理后停止线程\n}\n```","source":"_posts/HandlerThread-Handler-Thread.md","raw":"---\ntitle: 'HandlerThread, Handler, Thread, Runnable'\ndate: 2016-06-05 14:53:52\ncategories: Android\ntags:\n---\n\n![](/images/ckxt0.jpg)\n\nHandler会关联一个单独的线程和消息队列。\nHandler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。\n如果要在其他线程执行，可以使用HandlerThread。\nHandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。\n\n<!--more-->\n\n# HandlerThread的使用\n\n```java\n//Handler handler = new Handler() {\n//...\n//}\nHandlerThread uIhandlerThread = new HandlerThread(\"update\");\nuIhandlerThread.start();\n//Handler UIhandler = new Handler(uIhandlerThread.getLooper());\nHandler uIhandler = new Handler(uIhandlerThread.getLooper(), new Callback() {\n\tpublic boolean handleMessage(Message msg) {\n\tBundle b = msg.getData();\n\tint age = b.getInt(\"age\");\n\tString name = b.getString(\"name\");\n\tSystem.out.println(\"age is \" + age + \", name is\" + name);\n\tSystem.out.println(\"Handler--->\" + Thread.currentThread().getId());\n\tSystem.out.println(\"handlerMessage\");\n\treturn true;\n\t}\n});\n```\n\n当要停止uIhandlerThread执行时用：\n```java\nif (uIhandlerThread != null) {\n\tpointThread.quit();\n}\n```\n\n# Handler的使用\n\n目前常使用的有两种用法，\n一种是自定义Handler，在handleMessage进行事件的处理， 这个Message可以是在其他线程中send的，或者在主线程中send。\n在线程中发送信息到主进程：\n## 1. 定义handler\n\n```java\npublic class MyHandler extends Handler {\n\t@Override\n\tpublic boolean handleMessage(Message msg) {\n\t\tswitch (msg.what){\n\t\tcase 1 :\n\t\t....\n\t\t}\n\t}\n}\nMyHandler myHandler = new MyHandler();\n```\n\n或者\n\n```java\nHandler myHandler = new Handler(new Callback() {\n\t// 参数也可以为（this.getMainLooper()，new Callback(){}）不写则默认为主进程的Looper\n\t@Override\n\tpublic boolean handleMessage(Message msg) {\n\t\t// TODO Auto-generated method stub\n\t\treturn false;\n\t}\n});\n```\n\n## 2. 新建一个线程\n\n```java\nThread sender = new Thread(){\n\t@Override\n\tpublic void run() {\n\t\t....\n\t\t//Message msg = new Message();\n\t\tMessage msg = myHandler.obtainMessage(); //可以从handler中拿出message，省去了重新实例化的内存开销\n\t\t//myHandler.sendMessage(msg);\n\t\tmsg.sendToTarget();\n\t\t//myHandler.sendEmptyMessage(intWhat);\n\t}\n}\nsender.start();\n```\n\n在主线程中发信息到handler\n直接在主进程，不在线程中mHandler.sendMessage(msg);\n另一种为post一个线程进去，执行线程。直到线程退出或者是handler被removeCallbacks。\n定义一个线程Tread名为sender（不重复了）。\n然后执行，myHandler.post(sender);\n这样线程就在handler中执行。如果要停止线程的话：\n```java\nif(myHandler!=null) {\n\tmyHandler.removeCallbacks(senderObj);\n}\n```\n\n也可用一个Runnable来代替Thread\n\n```java\nRunnable r = new Runnable() {\n\n\t@Override\n\tpublic void run() {\n\t\t// TODO Auto-generated method stub\n\t}\n};\nmyHandler.post(r);\n```\n\n以上两种，是否使用handler的post来启动，差别在与是否开启新线程来执行处理。\n**使用post方法时，直接调用Thread或Runnable的run方法，所有处理都在主线程中进行，并没有开启定义的Thread或Runnable新的线程！！**\n\n# 关于Thread和Runnable的区别\n\nThread和Runnable是实现java多线程的两种方式，Thread是类，Runnable为接口，建议使用Runnable来实现多线程。\n如果让一个线程实现Runnable接口，那么当调用这个线程的对象开启多个线程时，可以让这些线程调用同一个变量；\n若这个线程是由继承Thread类而来，则要通过内部类来实现上述的功能，利用的就是内部类可任意访问外部类变量这个特性。（精辟！！）\n\n## 实现Runnable接口\n\n```java\npublic class ThreadTest {\n\tpublic static void main(String[] args) {\n\t\tMyThread mt=new MyThread();\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第一个线程\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第二个线程\n\t\tnew Thread(mt).start(); //通过实现Runnable的类的对象来开辟第三个线程\n\t\t//由于这三个线程是通过同一个对象mt开辟的，所以run()里方法访问的是同一个index\n\t}\n}\n```\n```java\n//实现Runnable接口\nclass MyThread implements Runnable {\n\tint index=0;\n\tpublic void run() {\n\t\tfor(;index<=200;)\n\t\tSystem.out.println(Thread.currentThread().getName()+\":\"+index++);\n\t}\n}\n```\n\n## 继承Thread\n\n```java\npublic class ThreadTest {\n\tpublic static void main(String[] args) {\n\t\tMyThread mt=new MyThread();\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第一个线程\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第二个线程\n\t\tmt.getThread().start(); //通过返回内部类的对象来开辟第三个线程\n\t\t//由于这三个线程是通过同一个匿名对象来开辟的，所以run()里方法访问的是同一个index\n\t}\n}\n```\n```java\nclass MyThread {\n\tint index=0;\n\t//定义一个内部类，继承Thread\n\tprivate class InnerClass extends Thread {\n\t\tpublic void run() {\n\t\t\tfor(;index<=200;)\n\t\t\tSystem.out.println(getName()+\":\"+index++);\n\t\t}\n\t}\n\t//这个函数的作用是返回InnerClass的一个匿名对象\n\tThread getThread() {\n\t\treturn new InnerClass();\n\t}\n}\n// 这里有一个问题：如果内部类要访问一个外部变量或方法，那么这个变量或方法必须定义为final，但为什么这里的变量index不用定义为final就可以被内部类访问？\n```\n\n# Thread的使用\n\n```java\nThread sender = new Thread(){\n\t@Override\n\tpublic void run() {\n\t\t....\n\t}\n}\nsender.start();\n```\n\n线程的停止\n```java\nif (sender != null) {\n\t//sender.quit();\n\tsender.join(); // 执行完毕当前处理后停止线程\n}\n```","slug":"HandlerThread-Handler-Thread","published":1,"updated":"2016-06-10T08:26:49.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipm4cr9x0003doucljt2nktb","content":"<p><img src=\"/images/ckxt0.jpg\" alt=\"\"></p>\n<p>Handler会关联一个单独的线程和消息队列。<br>Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。<br>如果要在其他线程执行，可以使用HandlerThread。<br>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>\n<a id=\"more\"></a>\n<h1 id=\"HandlerThread的使用\"><a href=\"#HandlerThread的使用\" class=\"headerlink\" title=\"HandlerThread的使用\"></a>HandlerThread的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Handler handler = new Handler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\">HandlerThread uIhandlerThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">uIhandlerThread.start();</span><br><span class=\"line\"><span class=\"comment\">//Handler UIhandler = new Handler(uIhandlerThread.getLooper());</span></span><br><span class=\"line\">Handler uIhandler = <span class=\"keyword\">new</span> Handler(uIhandlerThread.getLooper(), <span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\tBundle b = msg.getData();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age = b.getInt(<span class=\"string\">\"age\"</span>);</span><br><span class=\"line\">\tString name = b.getString(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"age is \"</span> + age + <span class=\"string\">\", name is\"</span> + name);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"Handler---&gt;\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"handlerMessage\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当要停止uIhandlerThread执行时用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (uIhandlerThread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\tpointThread.quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Handler的使用\"><a href=\"#Handler的使用\" class=\"headerlink\" title=\"Handler的使用\"></a>Handler的使用</h1><p>目前常使用的有两种用法，<br>一种是自定义Handler，在handleMessage进行事件的处理， 这个Message可以是在其他线程中send的，或者在主线程中send。<br>在线程中发送信息到主进程：</p>\n<h2 id=\"1-定义handler\"><a href=\"#1-定义handler\" class=\"headerlink\" title=\"1. 定义handler\"></a>1. 定义handler</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (msg.what)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span> :</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyHandler myHandler = <span class=\"keyword\">new</span> MyHandler();</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler myHandler = <span class=\"keyword\">new</span> Handler(<span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 参数也可以为（this.getMainLooper()，new Callback()&#123;&#125;）不写则默认为主进程的Looper</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-新建一个线程\"><a href=\"#2-新建一个线程\" class=\"headerlink\" title=\"2. 新建一个线程\"></a>2. 新建一个线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread sender = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t\t<span class=\"comment\">//Message msg = new Message();</span></span><br><span class=\"line\">\t\tMessage msg = myHandler.obtainMessage(); <span class=\"comment\">//可以从handler中拿出message，省去了重新实例化的内存开销</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//myHandler.sendMessage(msg);</span></span><br><span class=\"line\">\t\tmsg.sendToTarget();</span><br><span class=\"line\">\t\t<span class=\"comment\">//myHandler.sendEmptyMessage(intWhat);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sender.start();</span><br></pre></td></tr></table></figure>\n<p>在主线程中发信息到handler<br>直接在主进程，不在线程中mHandler.sendMessage(msg);<br>另一种为post一个线程进去，执行线程。直到线程退出或者是handler被removeCallbacks。<br>定义一个线程Tread名为sender（不重复了）。<br>然后执行，myHandler.post(sender);<br>这样线程就在handler中执行。如果要停止线程的话：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(myHandler!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\tmyHandler.removeCallbacks(senderObj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可用一个Runnable来代替Thread</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myHandler.post(r);</span><br></pre></td></tr></table></figure>\n<p>以上两种，是否使用handler的post来启动，差别在与是否开启新线程来执行处理。<br><strong>使用post方法时，直接调用Thread或Runnable的run方法，所有处理都在主线程中进行，并没有开启定义的Thread或Runnable新的线程！！</strong></p>\n<h1 id=\"关于Thread和Runnable的区别\"><a href=\"#关于Thread和Runnable的区别\" class=\"headerlink\" title=\"关于Thread和Runnable的区别\"></a>关于Thread和Runnable的区别</h1><p>Thread和Runnable是实现java多线程的两种方式，Thread是类，Runnable为接口，建议使用Runnable来实现多线程。<br>如果让一个线程实现Runnable接口，那么当调用这个线程的对象开启多个线程时，可以让这些线程调用同一个变量；<br>若这个线程是由继承Thread类而来，则要通过内部类来实现上述的功能，利用的就是内部类可任意访问外部类变量这个特性。（精辟！！）</p>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mt=<span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第一个线程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第二个线程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第三个线程</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//由于这三个线程是通过同一个对象mt开辟的，所以run()里方法访问的是同一个index</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现Runnable接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;index&lt;=<span class=\"number\">200</span>;)</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\":\"</span>+index++);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"继承Thread\"><a href=\"#继承Thread\" class=\"headerlink\" title=\"继承Thread\"></a>继承Thread</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mt=<span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第一个线程</span></span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第二个线程</span></span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第三个线程</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//由于这三个线程是通过同一个匿名对象来开辟的，所以run()里方法访问的是同一个index</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个内部类，继承Thread</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;index&lt;=<span class=\"number\">200</span>;)</span><br><span class=\"line\">\t\t\tSystem.out.println(getName()+<span class=\"string\">\":\"</span>+index++);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//这个函数的作用是返回InnerClass的一个匿名对象</span></span><br><span class=\"line\">\t<span class=\"function\">Thread <span class=\"title\">getThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里有一个问题：如果内部类要访问一个外部变量或方法，那么这个变量或方法必须定义为final，但为什么这里的变量index不用定义为final就可以被内部类访问？</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Thread的使用\"><a href=\"#Thread的使用\" class=\"headerlink\" title=\"Thread的使用\"></a>Thread的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread sender = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sender.start();</span><br></pre></td></tr></table></figure>\n<p>线程的停止<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sender != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//sender.quit();</span></span><br><span class=\"line\">\tsender.join(); <span class=\"comment\">// 执行完毕当前处理后停止线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","excerpt":"<p><img src=\"/images/ckxt0.jpg\" alt=\"\"></p>\n<p>Handler会关联一个单独的线程和消息队列。<br>Handler默认关联主线程，虽然要提供Runnable参数 ，但默认是直接调用Runnable中的run()方法。也就是默认下会在主线程执行，如果在这里面的操作会有阻塞，界面也会卡住。<br>如果要在其他线程执行，可以使用HandlerThread。<br>HandlerThread继承于Thread，所以它本质就是个Thread。与普通Thread的差别就在于，主要的作用是建立了一个线程，并且创立了消息队列，有来自己的looper,可以让我们在自己的线程中分发和处理消息。</p>","more":"<h1 id=\"HandlerThread的使用\"><a href=\"#HandlerThread的使用\" class=\"headerlink\" title=\"HandlerThread的使用\"></a>HandlerThread的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Handler handler = new Handler() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;</span></span><br><span class=\"line\">HandlerThread uIhandlerThread = <span class=\"keyword\">new</span> HandlerThread(<span class=\"string\">\"update\"</span>);</span><br><span class=\"line\">uIhandlerThread.start();</span><br><span class=\"line\"><span class=\"comment\">//Handler UIhandler = new Handler(uIhandlerThread.getLooper());</span></span><br><span class=\"line\">Handler uIhandler = <span class=\"keyword\">new</span> Handler(uIhandlerThread.getLooper(), <span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\tBundle b = msg.getData();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> age = b.getInt(<span class=\"string\">\"age\"</span>);</span><br><span class=\"line\">\tString name = b.getString(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"age is \"</span> + age + <span class=\"string\">\", name is\"</span> + name);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"Handler---&gt;\"</span> + Thread.currentThread().getId());</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"handlerMessage\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>当要停止uIhandlerThread执行时用：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (uIhandlerThread != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\tpointThread.quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Handler的使用\"><a href=\"#Handler的使用\" class=\"headerlink\" title=\"Handler的使用\"></a>Handler的使用</h1><p>目前常使用的有两种用法，<br>一种是自定义Handler，在handleMessage进行事件的处理， 这个Message可以是在其他线程中send的，或者在主线程中send。<br>在线程中发送信息到主进程：</p>\n<h2 id=\"1-定义handler\"><a href=\"#1-定义handler\" class=\"headerlink\" title=\"1. 定义handler\"></a>1. 定义handler</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (msg.what)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span> :</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyHandler myHandler = <span class=\"keyword\">new</span> MyHandler();</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler myHandler = <span class=\"keyword\">new</span> Handler(<span class=\"keyword\">new</span> Callback() &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 参数也可以为（this.getMainLooper()，new Callback()&#123;&#125;）不写则默认为主进程的Looper</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">handleMessage</span><span class=\"params\">(Message msg)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-新建一个线程\"><a href=\"#2-新建一个线程\" class=\"headerlink\" title=\"2. 新建一个线程\"></a>2. 新建一个线程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread sender = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t\t<span class=\"comment\">//Message msg = new Message();</span></span><br><span class=\"line\">\t\tMessage msg = myHandler.obtainMessage(); <span class=\"comment\">//可以从handler中拿出message，省去了重新实例化的内存开销</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//myHandler.sendMessage(msg);</span></span><br><span class=\"line\">\t\tmsg.sendToTarget();</span><br><span class=\"line\">\t\t<span class=\"comment\">//myHandler.sendEmptyMessage(intWhat);</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sender.start();</span><br></pre></td></tr></table></figure>\n<p>在主线程中发信息到handler<br>直接在主进程，不在线程中mHandler.sendMessage(msg);<br>另一种为post一个线程进去，执行线程。直到线程退出或者是handler被removeCallbacks。<br>定义一个线程Tread名为sender（不重复了）。<br>然后执行，myHandler.post(sender);<br>这样线程就在handler中执行。如果要停止线程的话：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(myHandler!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\tmyHandler.removeCallbacks(senderObj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可用一个Runnable来代替Thread</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable r = <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myHandler.post(r);</span><br></pre></td></tr></table></figure>\n<p>以上两种，是否使用handler的post来启动，差别在与是否开启新线程来执行处理。<br><strong>使用post方法时，直接调用Thread或Runnable的run方法，所有处理都在主线程中进行，并没有开启定义的Thread或Runnable新的线程！！</strong></p>\n<h1 id=\"关于Thread和Runnable的区别\"><a href=\"#关于Thread和Runnable的区别\" class=\"headerlink\" title=\"关于Thread和Runnable的区别\"></a>关于Thread和Runnable的区别</h1><p>Thread和Runnable是实现java多线程的两种方式，Thread是类，Runnable为接口，建议使用Runnable来实现多线程。<br>如果让一个线程实现Runnable接口，那么当调用这个线程的对象开启多个线程时，可以让这些线程调用同一个变量；<br>若这个线程是由继承Thread类而来，则要通过内部类来实现上述的功能，利用的就是内部类可任意访问外部类变量这个特性。（精辟！！）</p>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mt=<span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第一个线程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第二个线程</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">new</span> Thread(mt).start(); <span class=\"comment\">//通过实现Runnable的类的对象来开辟第三个线程</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//由于这三个线程是通过同一个对象mt开辟的，所以run()里方法访问的是同一个index</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//实现Runnable接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;index&lt;=<span class=\"number\">200</span>;)</span><br><span class=\"line\">\t\tSystem.out.println(Thread.currentThread().getName()+<span class=\"string\">\":\"</span>+index++);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"继承Thread\"><a href=\"#继承Thread\" class=\"headerlink\" title=\"继承Thread\"></a>继承Thread</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadTest</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tMyThread mt=<span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第一个线程</span></span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第二个线程</span></span><br><span class=\"line\">\t\tmt.getThread().start(); <span class=\"comment\">//通过返回内部类的对象来开辟第三个线程</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//由于这三个线程是通过同一个匿名对象来开辟的，所以run()里方法访问的是同一个index</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//定义一个内部类，继承Thread</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InnerClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;index&lt;=<span class=\"number\">200</span>;)</span><br><span class=\"line\">\t\t\tSystem.out.println(getName()+<span class=\"string\">\":\"</span>+index++);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//这个函数的作用是返回InnerClass的一个匿名对象</span></span><br><span class=\"line\">\t<span class=\"function\">Thread <span class=\"title\">getThread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> InnerClass();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这里有一个问题：如果内部类要访问一个外部变量或方法，那么这个变量或方法必须定义为final，但为什么这里的变量index不用定义为final就可以被内部类访问？</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Thread的使用\"><a href=\"#Thread的使用\" class=\"headerlink\" title=\"Thread的使用\"></a>Thread的使用</h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Thread sender = <span class=\"keyword\">new</span> Thread()&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t....</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sender.start();</span><br></pre></td></tr></table></figure>\n<p>线程的停止<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (sender != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//sender.quit();</span></span><br><span class=\"line\">\tsender.join(); <span class=\"comment\">// 执行完毕当前处理后停止线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"DatePickerDialog, TimePickerDialog在某些机型上会连续返回两次结果","date":"2016-06-10T08:46:55.000Z","_content":"\n继承系统的dialog，重写onStop方法\n\n<!--more-->\n\n```java\nclass CustomTimePicker extends TimePickerDialog {\n\n    public CustomTimePicker(Context context, OnTimeSetListener callBack, \n            int hourOfDay, int minute, boolean is24HourView) {\n        super(context, callBack, hourOfDay, minute, is24HourView);\n    }\n\n    @Override\n    protected void onStop() {}\n}\n```\n\n一样地，重写DatePickerDialog\n\n```java\nclass CustomDataPicker extends DatePickerDialog {\n\n    public CustomDataPicker(Context context, OnDateSetListener callBack,\n            int year, int monthOfYear, int dayOfMonth) {\n        super(context, callBack, year, monthOfYear, dayOfMonth);\n    }\n\n    @Override\n    protected void onStop() {}\n}\n```","source":"_posts/DatePickerDialog-TimePickerDialog在某些机型上会连续返回两次结果.md","raw":"---\ntitle: 'DatePickerDialog, TimePickerDialog在某些机型上会连续返回两次结果'\ndate: 2016-06-10 16:46:55\ncategories: Android\ntags:\n---\n\n继承系统的dialog，重写onStop方法\n\n<!--more-->\n\n```java\nclass CustomTimePicker extends TimePickerDialog {\n\n    public CustomTimePicker(Context context, OnTimeSetListener callBack, \n            int hourOfDay, int minute, boolean is24HourView) {\n        super(context, callBack, hourOfDay, minute, is24HourView);\n    }\n\n    @Override\n    protected void onStop() {}\n}\n```\n\n一样地，重写DatePickerDialog\n\n```java\nclass CustomDataPicker extends DatePickerDialog {\n\n    public CustomDataPicker(Context context, OnDateSetListener callBack,\n            int year, int monthOfYear, int dayOfMonth) {\n        super(context, callBack, year, monthOfYear, dayOfMonth);\n    }\n\n    @Override\n    protected void onStop() {}\n}\n```","slug":"DatePickerDialog-TimePickerDialog在某些机型上会连续返回两次结果","published":1,"updated":"2016-06-10T10:07:05.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipm4cra70009doucvu74v7us","content":"<p>继承系统的dialog，重写onStop方法</p>\n<a id=\"more\"></a>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomTimePicker</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimePickerDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomTimePicker</span><span class=\"params\">(Context context, OnTimeSetListener callBack, </span><br><span class=\"line\">            <span class=\"keyword\">int</span> hourOfDay, <span class=\"keyword\">int</span> minute, <span class=\"keyword\">boolean</span> is24HourView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, callBack, hourOfDay, minute, is24HourView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一样地，重写DatePickerDialog</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomDataPicker</span> <span class=\"keyword\">extends</span> <span class=\"title\">DatePickerDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomDataPicker</span><span class=\"params\">(Context context, OnDateSetListener callBack,</span><br><span class=\"line\">            <span class=\"keyword\">int</span> year, <span class=\"keyword\">int</span> monthOfYear, <span class=\"keyword\">int</span> dayOfMonth)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, callBack, year, monthOfYear, dayOfMonth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<p>继承系统的dialog，重写onStop方法</p>","more":"<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomTimePicker</span> <span class=\"keyword\">extends</span> <span class=\"title\">TimePickerDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomTimePicker</span><span class=\"params\">(Context context, OnTimeSetListener callBack, </span><br><span class=\"line\">            <span class=\"keyword\">int</span> hourOfDay, <span class=\"keyword\">int</span> minute, <span class=\"keyword\">boolean</span> is24HourView)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, callBack, hourOfDay, minute, is24HourView);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一样地，重写DatePickerDialog</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomDataPicker</span> <span class=\"keyword\">extends</span> <span class=\"title\">DatePickerDialog</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CustomDataPicker</span><span class=\"params\">(Context context, OnDateSetListener callBack,</span><br><span class=\"line\">            <span class=\"keyword\">int</span> year, <span class=\"keyword\">int</span> monthOfYear, <span class=\"keyword\">int</span> dayOfMonth)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, callBack, year, monthOfYear, dayOfMonth);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onStop</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用","date":"2016-06-10T07:24:15.000Z","_content":"\n# 问题描述\n\n1. 在 package installers 安装界面安装完一个应用后，直接打开app，然后进入了 Activity_1, 此时再通过此activity用startActivity(intent)的方法打开 Activity_2.\n2. 然后按home键返回桌面，在桌面点击app图标进入，你觉得应该进入的是 Activity_2，实际上却是Activity_1.\n3. 然而还没完，这时候你按 back 返回键，会发现返回到了之前打开的 Activity_2，再按返回，又出现 launcherActivity_1. 也就是说系统重复实例化了Activity_1.\n4. 退出app后再次点击桌面图标进入，反复试验，没有再出现这个问题。也就是说，这个问题（bug ？）只出现在操作步骤（1）后才会产生.\n\n<!--more-->\n\n# 解决方法\n\n在`super.onCreate(...)`方法中插入代码\n\n```java\nif(!this.isTaskRoot()) { \n    //判断该Activity是不是任务空间的源Activity，\"非\"也就是说是被系统重新实例化出来\n    //如果你就放在launcher Activity中话，这里可以直接return了\n    Intent mainIntent=getIntent();\n    String action=mainIntent.getAction();\n\n    if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) && action.equals(Intent.ACTION_MAIN)) {\n        finish();\n        return; //finish()之后该活动会继续执行后面的代码，你可以logCat验证，加return避免可能的exception\n    }\n}\n```","source":"_posts/首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用.md","raw":"---\ntitle: 首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用\ndate: 2016-06-10 15:24:15\ncategories: Android\ntags:\n---\n\n# 问题描述\n\n1. 在 package installers 安装界面安装完一个应用后，直接打开app，然后进入了 Activity_1, 此时再通过此activity用startActivity(intent)的方法打开 Activity_2.\n2. 然后按home键返回桌面，在桌面点击app图标进入，你觉得应该进入的是 Activity_2，实际上却是Activity_1.\n3. 然而还没完，这时候你按 back 返回键，会发现返回到了之前打开的 Activity_2，再按返回，又出现 launcherActivity_1. 也就是说系统重复实例化了Activity_1.\n4. 退出app后再次点击桌面图标进入，反复试验，没有再出现这个问题。也就是说，这个问题（bug ？）只出现在操作步骤（1）后才会产生.\n\n<!--more-->\n\n# 解决方法\n\n在`super.onCreate(...)`方法中插入代码\n\n```java\nif(!this.isTaskRoot()) { \n    //判断该Activity是不是任务空间的源Activity，\"非\"也就是说是被系统重新实例化出来\n    //如果你就放在launcher Activity中话，这里可以直接return了\n    Intent mainIntent=getIntent();\n    String action=mainIntent.getAction();\n\n    if (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) && action.equals(Intent.ACTION_MAIN)) {\n        finish();\n        return; //finish()之后该活动会继续执行后面的代码，你可以logCat验证，加return避免可能的exception\n    }\n}\n```","slug":"首次安装在安装界面打开应用，退到后台再从桌面launcher打开应用，会打开两个应用","published":1,"updated":"2016-06-10T08:28:29.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipm4cra8000adoucl8v6ini5","content":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><ol>\n<li>在 package installers 安装界面安装完一个应用后，直接打开app，然后进入了 Activity_1, 此时再通过此activity用startActivity(intent)的方法打开 Activity_2.</li>\n<li>然后按home键返回桌面，在桌面点击app图标进入，你觉得应该进入的是 Activity_2，实际上却是Activity_1.</li>\n<li>然而还没完，这时候你按 back 返回键，会发现返回到了之前打开的 Activity_2，再按返回，又出现 launcherActivity_1. 也就是说系统重复实例化了Activity_1.</li>\n<li>退出app后再次点击桌面图标进入，反复试验，没有再出现这个问题。也就是说，这个问题（bug ？）只出现在操作步骤（1）后才会产生.</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>在<code>super.onCreate(...)</code>方法中插入代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.isTaskRoot()) &#123; </span><br><span class=\"line\">    <span class=\"comment\">//判断该Activity是不是任务空间的源Activity，\"非\"也就是说是被系统重新实例化出来</span></span><br><span class=\"line\">    <span class=\"comment\">//如果你就放在launcher Activity中话，这里可以直接return了</span></span><br><span class=\"line\">    Intent mainIntent=getIntent();</span><br><span class=\"line\">    String action=mainIntent.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) &#123;</span><br><span class=\"line\">        finish();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">//finish()之后该活动会继续执行后面的代码，你可以logCat验证，加return避免可能的exception</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"<h1 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h1><ol>\n<li>在 package installers 安装界面安装完一个应用后，直接打开app，然后进入了 Activity_1, 此时再通过此activity用startActivity(intent)的方法打开 Activity_2.</li>\n<li>然后按home键返回桌面，在桌面点击app图标进入，你觉得应该进入的是 Activity_2，实际上却是Activity_1.</li>\n<li>然而还没完，这时候你按 back 返回键，会发现返回到了之前打开的 Activity_2，再按返回，又出现 launcherActivity_1. 也就是说系统重复实例化了Activity_1.</li>\n<li>退出app后再次点击桌面图标进入，反复试验，没有再出现这个问题。也就是说，这个问题（bug ？）只出现在操作步骤（1）后才会产生.</li>\n</ol>","more":"<h1 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h1><p>在<code>super.onCreate(...)</code>方法中插入代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.isTaskRoot()) &#123; </span><br><span class=\"line\">    <span class=\"comment\">//判断该Activity是不是任务空间的源Activity，\"非\"也就是说是被系统重新实例化出来</span></span><br><span class=\"line\">    <span class=\"comment\">//如果你就放在launcher Activity中话，这里可以直接return了</span></span><br><span class=\"line\">    Intent mainIntent=getIntent();</span><br><span class=\"line\">    String action=mainIntent.getAction();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mainIntent.hasCategory(Intent.CATEGORY_LAUNCHER) &amp;&amp; action.equals(Intent.ACTION_MAIN)) &#123;</span><br><span class=\"line\">        finish();</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">//finish()之后该活动会继续执行后面的代码，你可以logCat验证，加return避免可能的exception</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cipm4cr9p0000doucfsgg6got","category_id":"cipm4cr9v0002doucwtg9hbkk","_id":"cipm4cr9z0005doucn42mxj6d"},{"post_id":"cipm4cr9t0001douc0adlafy3","category_id":"cipm4cr9v0002doucwtg9hbkk","_id":"cipm4cra00007douclela2po2"},{"post_id":"cipm4cr9x0003doucljt2nktb","category_id":"cipm4cr9v0002doucwtg9hbkk","_id":"cipm4cra00008doucagwqfx5d"},{"post_id":"cipm4cra70009doucvu74v7us","category_id":"cipm4cr9v0002doucwtg9hbkk","_id":"cipm4craa000bdoucumjeqaxd"},{"post_id":"cipm4cra8000adoucl8v6ini5","category_id":"cipm4cr9v0002doucwtg9hbkk","_id":"cipm4crab000cdoucubvpu61l"}],"PostTag":[],"Tag":[]}}