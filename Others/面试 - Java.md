## 基础

#### 1. 如何理解面向对象（OOP）

我理解为是对现实世界的映射，比如一辆车可以行驶的行为是接口，车辆如何启动和前往目的地是类的实现，不关系一辆车的齿轮和发动机到底如何运作只用踩下油门和换挡是封装，有很多车但是使用相同的发动机底盘和变速器是继承，一个人只要考了C1驾照就能开全部的小型车是多态。

以一种更为符合人类的思维的方式去组织代码和把控工程。

### 2. 多态

事物在运行过程中存在不同的状态。多态可以分为编译时多态和运行时多态，编译时多态是指方法的重载，运行时多态是指方法的重写。

* 对于运行时多态需要满足以下三个条件：
  
  1. 要有继承关系
  2. 子类重写父类方法
  3. 父类对象的引用指向子类对象（SuperClass class = new ChildClass() ）

* 实现的机制

    其实就是依靠静态分派和动态分派。

    静态分派即在编译期间就能完全确定，在类加载的解析阶段就会把所涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成，典型的例子就是方法重载。

    动态分派是指在运行期间才能确定变量的实际类型，典型的例子就是方法的重写。只有在运行期间，根据对实例化子类的不同，调用不同子类中重写的方法。

    参考：多态性实现机制——静态分派与动态分派

### 3. 接口（Interface）与抽象类（Abstract Class）的区别

* 抽象层次不同。
  
  抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，所以由同一个抽象类继承出来的类属性和行为差别不会太大，但是接口却是对类局部（行为）进行抽象，而且这种行为是多种类都会具有，但是具体又不同的，具体的行为相差会很大。

* 跨域不同。

    抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。是”like-a”的关系。

* 设计层次不同。

    对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知，使用当前接口的类必须要实现对这个类的一套规范。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西（什么类）来实现这个飞接口，怎么实现（飞接口的具体实现）也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

> [深入java（类）设计层次看抽象类和接口](https://blog.csdn.net/yabay2208/article/details/73469643)

### 4. 重写（Override）与重载（Overload）的区别
### 5. 父类的静态方法能否被子类重写
### 6. 静态属性和静态方法是否可以被继承？是否可以被重写？为什么
### 7. 什么是内部类？内部类、静态内部类、局部内部类和匿名内部类的区别及作用
### 8. == 和 equals() 和 hashCode() 的区别
### 9. Integer 和 int 之间的区别
### 10. String 转换成 Integer 的方式及原理
### 11. 自动装箱实现原理？类型转换实现原理
### 12. String

* 对 String 的了解
* String 为什么要设计成不可变的
    
    需要综合内存,同步,数据结构以及安全等方面的考虑。再然后string不可变的设计不单单在于final关键字。因为string实现在一个char数组上，这个数组是可变的。所以还把内部的char数组作为私有常量，即private final。

    1. 字符串常量池的需要
    2. 保证hash值的唯一性

> [在java中String类为什么要设计成final？](https://www.zhihu.com/question/31345592)

* String,StringBuffer,StringBuilder的区别

  1. String是值不可变的，每次进行连接操作是都是返回一个新的String对象StringBuffer,StringBuilder是值可变的，操作是返回的是this这也就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。

  2. StringBuffer是线程同步的，安全性高，但执行效率低；StringBuilder是非线程同步的，安全性低，但执行效率高

### 13. final、finally 和 finalize 的区别
### 14. static 关键字有什么作用

### 20. 什么是序列化？怎么实现？有哪些方式？

序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。

Java 中，只有一种方式可以实现序列化，只需要实现 Serializable 接口。

在 Android 中，还有另外一种实现序列化的方式,实现 Parcelable，这个是 Android 独有的一种序列化方方式,相比较 Serializable，Parcelable 需要提供大量的模板代码，较为繁琐，但是效率比 Serializable 高出不少，因为 Serializable 实现的序列化利用反射，可能会进行频繁的IO操作，所以消耗比较大。而 Parcelable 则是在内存中进行序列化。

所以这里推荐的是：

* 内存序列化优先选择 Parcelable。
* 存储到设备优先选择 Serializable(这里推荐使用 json 方式加密保存在本地，比较简单)

### 21. 对反射的了解
### 22. 对注解的了解
### 23. 对依赖注入的了解
### 24. 对泛型的了解

类型擦除

### 25. 泛型中 extends 和 super 的区别
### 26. 对 Java 的异常体系的了解
### 27. 对解析与分派的了解
### 28. 静态代理和动态代理的区别？有什么场景使用
### 29. 谈谈对 Java 状态机理解

## 集合

### 15. 列举 Java 的集合以及集合之间的继承关系
### 16. List、Set、Map 的区别

List是有序元素的集合，Set是无序的、不可重复的元素的集合，Map是键值对的集合。

### 17. ArrayList、LinkedList 的区别

ArrayList底层实现为数组，允许null元素，增删慢查询快；LinkedList底层实现为链表，增删快查询慢。

### 18. HashMap，HashTable，ConcurrentHashMap 实现原理以及区别
### 19. HashSet 与 HashMap 怎么判断集合元素重复

引申：他们是如何解决Hash冲突的问题的

### HashMap的哈希散列实现，线程安全吗，为什么？
### ArrayList和Vector扩容的区别
### HashTable，ConcurrentHashMap怎么实现线程安全
### java8对hashmap的优化
### hashmap和hashset区别，hash怎么散列的

## 并发

### 1. 线程和进程的区别？
### 2. 开启线程的三种方式
### 如何正确的结束一个Thread?
### Thread 与 Runnable 的区别？
### run() 与 start() 方法的区别？
### sleep() 与 wait() 方法的区别？
### wait 与 notify 关键字的区别？
### synchronized 关键字的用法、作用及实现原理？
### volatile 关键字的用法、作用及实现原理？
### transient 关键字的用法、作用及实现原理？
### ReentrantLock、synchronized、volatile 之间的区别？
### 什么是线程池，如何使用?
### 多线程断点续传的实现原理？
### 什么是深拷贝和浅拷贝？
### Java 中对象的生命周期？
### 对并发编程的了解？
### 对Thread的理解？线程状态？阻塞和运行状态区别？
### 锁的种类，什么是自旋锁，ReentrantLock？
### 线程池怎么实现，阻塞队列原理？
### 可重入锁的实现，公平锁非公平锁都是什么定义？

### 线程池的实现

[深入分析java线程池的实现原理](https://www.jianshu.com/p/87bff5cc8d8c)

## JVM

### 简述 JVM 内存模型和内存区域？

**内存模型：**

Java 内存模型规定了所有的变量都是存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

![](https://camo.githubusercontent.com/417cc54bb8faab95e63a93d78488a92ff6baaf05/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666362313334373161382e6a7067)

**内存区域：**

![](https://camo.githubusercontent.com/c44e078a4b3eff770561f2c201c535c1c5c14917/68747470733a2f2f692e6c6f6c692e6e65742f323031382f31312f30352f356264666365353738633035352e6a7067)

内存区域可以分为以下几块：

* 程序计数器

    程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值为空。此内存区域是唯一一个没有规定任何 OOM 的区域。

* 虚拟机栈

    虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈桢用于存储局部变量表、操作数栈、动态链接地址、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机中入栈到出栈的过程。

* 本地方法栈

    本地方法栈和虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机执行 Native 方法服务。

* 堆

    Java 堆是虚拟机管理的内存中最大的一块，此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

* 方法区

    用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。相对而言，垃圾回收在这个区域是比较少出现的。

> [Java内存模型](https://www.jianshu.com/p/13b56ddad197)  
> [Java内存区域](https://www.jianshu.com/p/2f0742032ab3)

### jvm内存模型，新生代和老年代的比例？

1 : 2

### 新生代里怎么划分？好处？

新生代又被划分为三个区域：Eden、From Survivor、To Survivor。

这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

![](https://images0.cnblogs.com/blog/587773/201409/061921034534396.png)

JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

### GC机制

* 引用计数算法（Reference Counting）

    给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的，这就是引用计数算法的核心。客观来讲，引用计数算法实现简单，判定效率也很高，在大部分情况下都是一个不错的算法。但是Java虚拟机并没有采用这个算法来判断何种对象为死亡对象，因为它很难解决对象之间相互循环引用的问题。

* 可达性分析算法（Reachability Analysis）

    这是Java虚拟机采用的判定对象是否存活的算法。通过一系列的称为“GC Roots"的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径称为饮用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。可作为GC Roots的对象包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象。本地方法栈JNI引用的对象。

* 新生代——复制整理算法
* 老年代——标记清除算法