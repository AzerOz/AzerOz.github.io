## 基础

#### 1. 如何理解面向对象（OOP）

我理解为是对现实世界的映射，比如一辆车可以行驶的行为是接口，车辆如何启动和前往目的地是类的实现，不关系一辆车的齿轮和发动机到底如何运作只用踩下油门和换挡是封装，有很多车但是使用相同的发动机底盘和变速器是继承，一个人只要考了C1驾照就能开全部的小型车是多态。

以一种更为符合人类的思维的方式去组织代码和把控工程。

### 2. 多态

事物在运行过程中存在不同的状态。多态可以分为编译时多态和运行时多态，编译时多态是指方法的重载，运行时多态是指方法的重写。

* 对于运行时多态需要满足以下三个条件：
  
  1. 要有继承关系
  2. 子类重写父类方法
  3. 父类对象的引用指向子类对象（SuperClass class = new ChildClass() ）

* 实现的机制

    其实就是依靠静态分派和动态分派。

    静态分派即在编译期间就能完全确定，在类加载的解析阶段就会把所涉及的符号引用转化为可确定的直接引用，不会延迟到运行期再去完成，典型的例子就是方法重载。

    动态分派是指在运行期间才能确定变量的实际类型，典型的例子就是方法的重写。只有在运行期间，根据对实例化子类的不同，调用不同子类中重写的方法。

    参考：多态性实现机制——静态分派与动态分派

### 3. 接口（Interface）与抽象类（Abstract Class）的区别

* 抽象层次不同。
  
  抽象类是对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，所以由同一个抽象类继承出来的类属性和行为差别不会太大，但是接口却是对类局部（行为）进行抽象，而且这种行为是多种类都会具有，但是具体又不同的，具体的行为相差会很大。

* 跨域不同。

    抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。我们知道抽象类是从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同。实现它的子类可以不存在任何关系，共同之处。例如猫、狗可以抽象成一个动物类抽象类，具备叫的方法。鸟、飞机可以实现飞Fly接口，具备飞的行为，这里我们总不能将鸟、飞机共用一个父类吧！所以说抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。是”like-a”的关系。

* 设计层次不同。

    对于抽象类而言，它是自下而上来设计的，我们要先知道子类才能抽象出父类，而接口则不同，它根本就不需要知道子类的存在，只需要定义一个规则即可，至于什么子类、什么时候怎么实现它一概不知，使用当前接口的类必须要实现对这个类的一套规范。比如我们只有一个猫类在这里，如果你这是就抽象成一个动物类，是不是设计有点儿过度？我们起码要有两个动物类，猫、狗在这里，我们在抽象他们的共同点形成动物抽象类吧！所以说抽象类往往都是通过重构而来的！但是接口就不同，比如说飞，我们根本就不知道会有什么东西（什么类）来实现这个飞接口，怎么实现（飞接口的具体实现）也不得而知，我们要做的就是事前定义好飞的行为接口。所以说抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。

> [深入java（类）设计层次看抽象类和接口](https://blog.csdn.net/yabay2208/article/details/73469643)

### 4. 重写（Override）与重载（Overload）的区别
### 5. 父类的静态方法能否被子类重写
### 6. 静态属性和静态方法是否可以被继承？是否可以被重写？为什么
### 7. 什么是内部类？内部类、静态内部类、局部内部类和匿名内部类的区别及作用
### 8. == 和 equals() 和 hashCode() 的区别
### 9. Integer 和 int 之间的区别
### 10. String 转换成 Integer 的方式及原理
### 11. 自动装箱实现原理？类型转换实现原理
### 12. String

* 对 String 的了解
* String 为什么要设计成不可变的
    
    需要综合内存,同步,数据结构以及安全等方面的考虑。再然后string不可变的设计不单单在于final关键字。因为string实现在一个char数组上，这个数组是可变的。所以还把内部的char数组作为私有常量，即private final。

    1. 字符串常量池的需要
    2. 保证hash值的唯一性

> [在java中String类为什么要设计成final？](https://www.zhihu.com/question/31345592)

* String,StringBuffer,StringBuilder的区别

  1. String是值不可变的，每次进行连接操作是都是返回一个新的String对象StringBuffer,StringBuilder是值可变的，操作是返回的是this这也就是为什么在进行大量字符串连接运算时，不推荐使用String，而推荐StringBuffer和StringBuilder。

  2. StringBuffer是线程同步的，安全性高，但执行效率低；StringBuilder是非线程同步的，安全性低，但执行效率高

### 13. final、finally 和 finalize 的区别
### 14. static 关键字有什么作用
### 15. 列举 Java 的集合以及集合之间的继承关系
### 16. List、Set、Map 的区别

List是有序元素的集合，Set是无序的、不可重复的元素的集合，Map是键值对的集合。

### 17. ArrayList、LinkedList 的区别

ArrayList底层实现为数组，允许null元素，增删慢查询快；LinkedList底层实现为链表，增删快查询慢。

### 18. HashMap，HashTable，ConcurrentHashMap 实现原理以及区别
### 19. HashSet 与 HashMap 怎么判断集合元素重复

引申：他们是如何解决Hash冲突的问题的

### 20. 什么是序列化？怎么实现？有哪些方式？

序列化是一种将对象转换为字节流的过程，目的是为了将该对象存储到内存中，等后面再次构建该对象时可以获取到该对象先前的状态及数据信息。

Java 中，只有一种方式可以实现序列化，只需要实现 Serializable 接口。

在 Android 中，还有另外一种实现序列化的方式,实现 Parcelable，这个是 Android 独有的一种序列化方方式,相比较 Serializable，Parcelable 需要提供大量的模板代码，较为繁琐，但是效率比 Serializable 高出不少，因为 Serializable 实现的序列化利用反射，可能会进行频繁的IO操作，所以消耗比较大。而 Parcelable 则是在内存中进行序列化。

所以这里推荐的是：

* 内存序列化优先选择 Parcelable。
* 存储到设备优先选择 Serializable(这里推荐使用 json 方式加密保存在本地，比较简单)

### 21. 对反射的了解
### 22. 对注解的了解
### 23. 对依赖注入的了解
### 24. 对泛型的了解
### 25. 泛型中 extends 和 super 的区别
### 26. 对 Java 的异常体系的了解
### 27. 对解析与分派的了解
### 28. 静态代理和动态代理的区别？有什么场景使用
### 29. 谈谈对 Java 状态机理解

## 并发

### 1. 线程和进程的区别？
### 2. 开启线程的三种方式
### 如何正确的结束一个Thread?
### Thread 与 Runnable 的区别？
### run() 与 start() 方法的区别？
### sleep() 与 wait() 方法的区别？
### wait 与 notify 关键字的区别？
### synchronized 关键字的用法、作用及实现原理？
### volatile 关键字的用法、作用及实现原理？
### transient 关键字的用法、作用及实现原理？
### ReentrantLock、synchronized、volatile 之间的区别？
### 什么是线程池，如何使用?
### 多线程断点续传的实现原理？
### 什么是深拷贝和浅拷贝？
### Java 中对象的生命周期？
### 对并发编程的了解？